---
id: a9692f0b-028e-47a2-a101-3e2caef5d97b
subject: >-
  Looking at the code: 1. **MCP Server (daemon)**: - Uses stdio transport for
  MCP protocol...
applies_to: global
occurred_at: '2025-12-03T09:50:37.333Z'
content_hash: 87b6367191ad0ec0
---
## Thought

Looking at the code:

1. **MCP Server (daemon)**: 
   - Uses stdio transport for MCP protocol communication
   - Runs background daemon loops for transcript processing
   - Has direct database access via getVectorStore() and getThinkingVectorStore()

2. **Hooks**:
   - Run as separate Node.js processes spawned by Claude Code
   - Each hook process loads sqlite-vec independently
   - No IPC mechanism to the daemon - they're completely independent

Currently there's **NO** communication between hooks and the MCP daemon. They're:
- Separate processes
- Both load sqlite-vec independently
- Both access the same SQLite database file
- File-based locking tries to prevent concurrent sqlite-vec loading but may have race conditions

**Could hooks communicate with the daemon?**

Yes, this is possible. Options include:

1. **Unix domain socket** - Daemon listens on a socket, hooks connect as clients
2. **Named pipe / FIFO** - Similar to socket
3. **HTTP/REST API** - Daemon exposes localhost HTTP server
4. **MCP protocol itself** - Hooks could be MCP clients to the daemon

The cleanest solution would be for hooks to be thin clients that forward search requests to the daemon via a local socket or HTTP endpoint. This way:
- Only the daemon loads sqlite-vec
- Hooks just send requests and receive responses
- No concurrent native code loading issues

Let me check if there's any socket/HTTP infrastructure already in place.

## Output

Looking at the code, **no** - currently there's no communication between hooks and the daemon. They are completely independent:

## Current Architecture

```
┌─────────────────────┐     ┌─────────────────────┐     ┌─────────────────────┐
│   MCP Daemon        │     │  Hook Process 1     │     │  Hook Process 2     │
│   (server.ts)       │     │  (user-prompt...)   │     │  (session-start...) │
├─────────────────────┤     ├─────────────────────┤     ├─────────────────────┤
│ • Loads sqlite-vec  │     │ • Loads sqlite-vec  │     │ • Loads sqlite-vec  │
│ • Opens DB directly │     │ • Opens DB directly │     │ • Opens DB directly │
│ • Runs extraction   │     │ • Runs search       │     │ • Lists memories    │
└─────────┬───────────┘     └─────────┬───────────┘     └─────────┬───────────┘
          │                           │                           │
          └───────────────────────────┼───────────────────────────┘
                                      │
                              ┌───────▼───────┐
                              │ memory.sqlite │
                              │ (file-locked) │
                              └───────────────┘
```

Each process:
1. Spawns independently
2. Loads sqlite-vec native extension
3. Opens the database directly
4. Uses file-based locking (`acquireLock()` in `database.ts:53`)

## The Problem

The file-based lock only serializes database *opening*, not sqlite-vec *loading*. If two processes try to load the native extension simultaneously, the C++ mutexes can conflict.

## Solution: Daemon as Search Service

Yes, hooks **could** communicate with the daemon. Options:

| Method | Pros | Cons |
|--------|------|------|
| **Unix socket** | Fast, native IPC | Platform-specific |
| **HTTP localhost** | Simple, cross-platform | Port conflicts, overhead |
| **Named pipe** | Simple on Unix | Windows compatibility |
| **Existing MCP protocol** | Already implemented | Hooks would need MCP client |

### Recommended Architecture

```
┌─────────────────────┐     ┌─────────────────────┐
│   MCP Daemon        │     │  Hook Process       │
│   (server.ts)       │◄────│  (thin client)      │
├─────────────────────┤ IPC ├─────────────────────┤
│ • Loads sqlite-vec  │     │ • HTTP/socket call  │
│ • Owns DB access    │     │ • No sqlite-vec     │
│ • Exposes search API│     │ • Waits for response│
└─────────┬───────────┘     └─────────────────────┘
          │
  ┌───────▼───────┐
  │ memory.sqlite │
  └───────────────┘
```

The daemon would expose a simple HTTP endpoint (e.g., `localhost:19842/search`) and hooks would be thin clients that don't load sqlite-vec at all.

Would you like me to implement this?
