---
id: ee0a118b-6744-46b0-9137-d89054927c32
subject: >-
  The user is asking me to extract memories from a Claude Code session
  transcript. Let me analyze...
applies_to: global
occurred_at: '2025-12-21T19:21:05.658Z'
content_hash: 764dd16ff837cc19
---
## Thought

The user is asking me to extract memories from a Claude Code session transcript. Let me analyze what was learned and discovered in this session.

Looking at the transcript, this session was about fixing a "mutex lock failed: Invalid argument" error in the local-recall project. Here's what was discovered and solved:

## What was learned:

1. **Root cause of the mutex error**: The singleton pattern with persistent database connections combined with sqlite-vec's internal mutexes was causing the error. When the process exits, Node.js garbage collects objects unpredictably, and sqlite-vec mutexes could be destroyed while cleanup code was still using them.

2. **The solution**: Move to ephemeral connections - create fresh database connections for each atomic operation instead of holding singleton connections.

3. **Specific threading issue**: The sqlite-vec native extension uses internal mutexes that don't play well with persistent connections across the hook execution lifecycle.

4. **Related issue with SearchEngine**: The SearchEngine wasn't passing the baseDir to getVectorStore(), which masked the issue with the singleton pattern. Now that connections are ephemeral, each call needs the correct baseDir.

5. **Architecture pattern**: The local-recall system uses Orama (pure JavaScript) for vector storage and sqlite-vec for the backend. The issue was in how connections were managed.

6. **Important discovery**: The old singleton pattern masked connection path issues - when using the legacy constructor `SearchEngine(memoryManager)`, the SearchEngine needs to know the MemoryManager's baseDir to create connections in the right location.

## Code changes made:

1. **`src/core/vector-store.ts`**: Refactored to use ephemeral connections instead of singletons
2. **`src/core/thinking-vector-store.ts`**: Same refactoring for thinking vector store
3. **`src/core/memory.ts`**: Added a getter to expose baseDir
4. **`src/core/search.ts`**: Updated to pass baseDir when creating SearchEngine from MemoryManager


5. **`src/core/thinking-search.ts`**: Implemented similar connection management updates for thinking search components

I'll focus on the key modifications to the thinking search module, ensuring consistent ephemeral connection handling across the system's memory management infrastructure.

The sqlite-vec extension presents challenges with connection persistence, particularly around mutex implementations and process lifecycle interactions. Constructor-based initialization requires careful baseDir configuration to prevent connection leakage and ensure proper isolation between memory operations.

Rigorous testing with custom path configurations will be critical for identifying and mitigating potential connection management vulnerabilities.

## Output

```json
{
  "memories": [
    {
      "subject": "Mutex lock error caused by persistent sqlite-vec connections - solved with ephemeral connections",
      "keywords": ["mutex", "sqlite-vec", "threading", "database connection", "garbage collection", "singleton", "error handling"],
      "applies_to": "global",
      "content": "## Problem\n\nThe error `libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument` occurred in UserPromptSubmit hook because:\n\n1. **Persistent singleton connections**: `getVectorStore()` and `getThinkingVectorStore()` created singleton instances with database connections that persisted for the process lifetime\n2. **sqlite-vec native extension mutexes**: The sqlite-vec extension uses internal mutexes that don't safely handle persistent connections\n3. **Unpredictable garbage collection**: When the process exits, Node.js garbage collects objects in an unpredictable order, causing mutexes to be destroyed while cleanup code was still trying to acquire them\n\n## Solution\n\nRefactored both `vector-store.ts` and `thinking-vector-store.ts` to use **ephemeral connections**:\n- Each atomic operation (add, remove, search, sync, etc.) creates a fresh database connection\n- Connections are closed immediately after the operation completes\n- No singleton pattern - each call to `getVectorStore()` returns a new instance with its own connection\n\n## Files Modified\n\n- `src/core/vector-store.ts` - Refactored to ephemeral connections\n- `src/core/thinking-vector-store.ts` - Same ephemeral connection pattern\n- `src/core/search.ts` - Now receives baseDir to pass to getVectorStore()\n- `src/core/thinking-search.ts` - Same update for thinking search\n- `src/core/memory.ts` - Added getBaseDir() getter\n\n## Key Insight\n\nThe old singleton pattern masked an additional issue: SearchEngine wasn't passing baseDir to getVectorStore(), so it defaulted to the global config.memoryDir instead of using the same directory as the MemoryManager. This broke custom baseDir paths used in tests."
    },
    {
      "subject": "SearchEngine needs baseDir passed explicitly when initialized from MemoryManager",
      "keywords": ["SearchEngine", "MemoryManager", "baseDir", "constructor", "initialization", "legacy pattern"],
      "applies_to": "file:src/core/search.ts",
      "content": "## Issue\n\nWhen using the legacy constructor `SearchEngine(memoryManager)`, the SearchEngine doesn't receive the baseDir from the MemoryManager. It instead calls `getVectorStore()` without baseDir, which defaults to using `config.memoryDir` from global config.\n\nThis breaks in two scenarios:\n1. Tests that use custom baseDirs\n2. Systems with multiple projects using different local-recall directories\n\n## Solution\n\nAdded `getBaseDir()` getter to MemoryManager and updated SearchEngine constructor to:\n```typescript\nif ('writeMemory' in options) {\n  // Legacy constructor: MemoryManager passed directly\n  this.baseDir = options.getBaseDir();\n}\n```\n\nThen pass `baseDir: this.baseDir` when calling `getVectorStore()` in the search method.\n\n## Why This Matters\n\nWith ephemeral connections, each `search()` call needs the correct baseDir. The singleton pattern masked this requirement because the first call set the path and all subsequent calls reused that instance."
    },
    {
      "subject": "sqlite-vec uses persistent native connections that don't work across hook lifecycle",
      "keywords": ["sqlite-vec", "native extension", "database", "hooks", "process lifecycle", "connection pooling"],
      "applies_to": "global",
      "content": "## Discovery\n\nThe local-recall hooks (UserPromptSubmit, SessionStart, Stop) invoke Orama/sqlite-vec operations. The sqlite-vec native extension maintains internal mutexes that assume exclusive access to the database connection within a single operation.\n\n## The Problem\n\nWhen connections persist across multiple hook invocations (via singleton pattern), the mutexes can be left in a bad state. Additionally, when the Node.js process exits, garbage collection order is unpredictable - sometimes mutex cleanup code runs after the mutex has been destroyed.\n\n## The Fix\n\nUse **ephemeral connections** for each atomic operation:\n- Each `add()`, `remove()`, `search()`, `sync()` creates a fresh connection\n- Connection is closed immediately after the operation\n- This ensures each operation has exclusive access to the connection\n- Prevents mutex state issues across operation boundaries\n\n## Implementation Details\n\nBoth `vector-store.ts` and `thinking-vector-store.ts` were refactored to close connections after each method completes, typically using a try/finally pattern or by awaiting the operation and immediately closing."
    }
  ]
}
```
