---
id: 830b3de5-8fa7-4a82-af90-bcbc1a42bec0
subject: >-
  Now I understand the issue better. Looking at the code: 1. The `database.ts`
  has file-based locking...
applies_to: global
occurred_at: '2025-12-03T10:02:43.241Z'
content_hash: b603c3201a237d16
---
## Thought

Now I understand the issue better. Looking at the code:

1. The `database.ts` has file-based locking (`acquireLock`) to prevent concurrent sqlite-vec loading
2. However, the issue is that **within the same process**, when both `handleEpisodicSearch` and `handleThinkingSearch` run:
   - Each creates a new VectorStore instance
   - Each calls `initialize()` which calls `embeddingService.initialize()`
   - Each then calls `openConnection()` which calls `openDatabase()` which loads sqlite-vec

The file-based locking helps with **inter-process** concurrency, but **within the same process**, the issue is different:

1. The embedding service is a singleton - good
2. But sqlite-vec is loaded **every time a connection is opened** (each call to `openDatabase` calls `sqliteVec.load(db)`)

The problem is that sqlite-vec might have internal state that doesn't like being loaded into multiple database connections within the same process simultaneously. Even with the file lock, if both searches are happening in the same daemon process:

1. Episodic search: acquires lock, loads sqlite-vec into db1, releases lock
2. Thinking search: acquires lock, loads sqlite-vec into db2, releases lock
3. Both dbs now have sqlite-vec loaded
4. Both try to do vector operations at roughly the same time
5. The internal mutex in sqlite-vec fails

Wait, but looking more closely at the HTTP server:

```javascript
async function handleEpisodicSearch(req, res) {
  // ...
  if (!searchEngine) {
    searchEngine = new SearchEngine({ memoryManager, readonly: false });
  }
  const results = await searchEngine.search(body.query, {...});
  // ...
}

async function handleThinkingSearch(req, res) {
  // ...
  if (!thinkingSearchEngine) {
    thinkingSearchEngine = new ThinkingSearchEngine({ readonly: false });
  }
  const results = await thinkingSearchEngine.search(body.query, {...});
  // ...
}
```

The search engines are lazily initialized and cached, but each search operation triggers a new database connection. When episodic and thinking searches occur simultaneously, they might both open connections and load sqlite-vec at overlapping times, potentially causing race conditions in the library's internal state management.

The file-based locking mechanism provides some protection, but doesn't fully prevent concurrent loading within the same process. This suggests we need a more robust synchronization strategy to ensure safe sqlite-vec initialization and connection management.

The current lock implementation releases its hold immediately after loading the library, which leaves a narrow window for potential concurrent access and potential library state conflicts. This means even with file-based locking, there's still a risk of race conditions during the initialization phase.

The sequence reveals a critical synchronization problem where multiple queries could potentially load sqlite-vec simultaneously, triggering mutex-related errors. The C++ exception specifically points to low-level mutex operation failures, indicating deep threading synchronization challenges.

Potential strategies involve maintaining a persistent lock throughout database operations, establishing a single shared connection, or implementing higher-level serialization mechanisms to prevent concurrent library initialization and database access.

I'll investigate the server's request handling to understand potential concurrency risks and design an appropriate synchronization approach.

## Output

Found the issue! The problem is that both episodic and thinking searches run **concurrently within the same daemon process**, and each search:

1. Opens a new database connection via `openConnection()`
2. Loads `sqlite-vec` into that connection
3. The file lock only protects the `sqliteVec.load()` call, not the subsequent operations

When both searches run at the same time, you get:
- Two separate database connections with sqlite-vec loaded
- Both trying to do vector operations simultaneously
- sqlite-vec's internal mutex gets corrupted

The issue is in `http-server.ts` where `handleEpisodicSearch` and `handleThinkingSearch` can be called concurrently from the user-prompt-submit hook (which calls both sequentially but the HTTP server handles them asynchronously).

Let me check if the user-prompt-submit hook runs these searches in parallel:
