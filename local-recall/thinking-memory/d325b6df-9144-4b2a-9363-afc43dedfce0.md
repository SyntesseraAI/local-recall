---
id: d325b6df-9144-4b2a-9363-afc43dedfce0
subject: >-
  I've written the final plan to the plan file. Now I should call ExitPlanMode
  to present the plan to...
applies_to: global
occurred_at: '2025-12-21T17:41:03.632Z'
content_hash: ad7b63cfdea29ef0
---
## Thought

I've written the final plan to the plan file. Now I should call ExitPlanMode to present the plan to the user for approval.

## Output

I've completed the plan. Here's a summary:

## Plan Overview

**Goal**: Migrate from individual markdown files to JSONL format with three entry types:
- `add` - Full memory data (without embedding)
- `delete` - Marks a memory as deleted by ID
- `embedding` - Stores the 768-dimension vector for a memory

**Key Design Points:**
1. Two JSONL files: `episodic.jsonl` and `thinking.jsonl` in the root `local-recall/` folder
2. Keep Orama indexes for fast vector search
3. Auto-compact when file grows large or has many deletions
4. Delete old `episodic-memory/` and `thinking-memory/` folders after migration

**Implementation Phases:**
1. Create JSONL infrastructure (types, generic store, specific stores)
2. Modify `MemoryManager` and `ThinkingMemoryManager` to use JSONL
3. Update `VectorStore` to support pre-computed embeddings
4. Create migration service
5. Implement auto-compaction

`★ Insight ─────────────────────────────────────`
The JSONL append-only log pattern (already used in `processed-log.ts`) is ideal here because:
- Appends are atomic on most filesystems
- No locking needed for concurrent reads
- Easy to replay and rebuild state
- Git-friendly (changes are additions, not rewrites)
`─────────────────────────────────────────────────`
