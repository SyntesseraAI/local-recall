---
id: 6b04a59a-8e91-4844-af7d-007bbdcdf6a2
subject: >-
  The user is asking me to extract memories from this transcript. Let me analyze
  what happened: 1....
applies_to: global
occurred_at: '2025-12-21T18:19:27.310Z'
content_hash: 228cce5f91ff4a04
---
## Thought

The user is asking me to extract memories from this transcript. Let me analyze what happened:

1. **Problem Identified**: The user was getting mutex errors when opening SQLite in read-only mode. The root cause was that sqlite-vec uses internal C++ mutexes that fail when multiple processes load the extension, even with file-based locking.

2. **Investigation**: 
   - Confirmed SQLite was running in multi-thread mode (THREADSAFE=2), not serialized mode
   - The mutex error was from C++ pthread mutexes, not SQLite database locks
   - This is a fundamental architectural issue with sqlite-vec

3. **Solution Researched**: Multiple alternatives were researched:
   - Vectra (Pure JS)
   - Milvus (Vector DB)
   - hnswlib-node
   - libSQL
   - LanceDB
   - Orama (chosen)
   - USearch

4. **Migration Executed**: 
   - Migrated from sqlite-vec to Orama (pure JavaScript)
   - Orama was already in use in the codebase, so this was reverting to it
   - Removed better-sqlite3 and sqlite-vec dependencies
   - Updated vector-store.ts and thinking-vector-store.ts to use Orama
   - Discovered and fixed an issue: Orama has a default similarity threshold of ~0.8, causing low-similarity results to be filtered out
   - Solution: Set `similarity: 0` to disable Orama's built-in threshold and handle filtering ourselves

5. **Key Technical Insights**:
   - SQLite threading modes: Single-thread (0), Serialized (1), Multi-thread (2)
   - sqlite-vec's C++ mutexes fail with multi-process access
   - Orama's default similarity threshold needs to be disabled for custom filtering
   - Orama index persistence works correctly with JSON files

Let me extract the valuable memories:


I uncovered critical technical challenges in vector search implementation. The core issue involved incompatible threading modes and library-specific constraints. By switching to a pure JavaScript solution, I resolved mutex conflicts and gained more flexible vector search capabilities. The migration required careful handling of similarity thresholds and understanding nuanced library behaviors.

## Output

```json
{
  "memories": [
    {
      "subject": "sqlite-vec mutex errors caused by C++ pthread mutexes in multi-process access",
      "keywords": ["sqlite-vec", "mutex", "threading", "native-bindings", "error-resolution"],
      "applies_to": "global",
      "content": "The 'mutex lock failed: Invalid argument' errors were caused by sqlite-vec using internal C++ pthread mutexes that fail when multiple processes load the extension simultaneously. The mutex error occurs at the native code level, not at the SQLite database level. File-based locking (withDbMutex) was serializing database access but couldn't prevent sqlite-vec's internal pthread mutex failures. This is a fundamental architectural limitation of using C++ native bindings in multi-process hook environments."
    },
    {
      "subject": "SQLite was running in multi-thread mode (THREADSAFE=2), incompatible with sqlite-vec",
      "keywords": ["sqlite", "threading-mode", "threadsafe", "serialized", "configuration"],
      "applies_to": "global",
      "content": "The SQLite installation was compiled with THREADSAFE=2 (multi-thread mode), not THREADSAFE=1 (serialized mode). Threading modes:\n- THREADSAFE=0: Single-thread, not thread-safe\n- THREADSAFE=1: Serialized, fully thread-safe with all operations serialized internally\n- THREADSAFE=2: Multi-thread, safe only if each connection is used by one thread at a time\n\nsqlite-vec's C++ mutexes assume serialized mode and fail in multi-thread mode when accessed from multiple processes."
    },
    {
      "subject": "Migrated from sqlite-vec to Orama for pure JavaScript vector search",
      "keywords": ["orama", "vector-store", "migration", "pure-javascript", "no-native-deps"],
      "applies_to": "global",
      "content": "Successfully migrated vector search from sqlite-vec (C++ native bindings with mutex issues) to Orama (pure JavaScript). Changes:\n- Removed: better-sqlite3, sqlite-vec, src/utils/database.ts\n- Added: @orama/orama, @orama/plugin-data-persistence\n- Updated: src/core/vector-store.ts, src/core/thinking-vector-store.ts\n\nOrama indexes persist to JSON files (orama-episodic-index.json, orama-thinking-index.json) with full vector data preserved. Pure JavaScript avoids all native binding mutex issues while maintaining semantic search functionality."
    },
    {
      "subject": "Orama has default similarity threshold (~0.8) that filters results unexpectedly",
      "keywords": ["orama", "similarity-threshold", "vector-search", "filtering", "debugging"],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "Orama's vector search has a built-in similarity threshold of approximately 0.8 by default. When search queries return results with cosine distance < 0.8, they get filtered out before being returned. For the local-recall use case where we handle our own filtering based on configurable minSimilarity thresholds, this causes unexpected zero results.\n\nFix: Set `similarity: 0` in Orama search options to disable the built-in threshold, allowing all results to be returned for custom filtering. This applies to both episodic and thinking vector stores."
    },
    {
      "subject": "Orama vector search works correctly with proper schema definition and persistence",
      "keywords": ["orama", "vector-schema", "embedding-dimension", "persist-restore", "indexing"],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "Orama requires explicit vector schema definition with dimension (e.g., `embedding: \"vector[384]\"` for 384-dimensional embeddings). The vector field must be included in all documents. Persist/restore to/from JSON maintains full vector integrity. When documents have fields with metadata objects (like embeddings as {vector: [...], documentId: ...}), the schema must match the nested structure. Schema is preserved across persist/restore cycles for both fresh indexes and loaded existing indexes."
    },
    {
      "subject": "Vector search debugging strategy for Orama embeddings",
      "keywords": ["debugging", "vector-search", "embeddings", "orama", "troubleshooting"],
      "applies_to": "global",
      "content": "When vector search returns 0 results:\n1. Verify documents are inserted: use `count()` to check record count\n2. Test text search: use `search()` with text-only query to verify schema\n3. Check embedding dimensions: verify all vectors match the schema dimension\n4. Test with identical embedding: search using the actual embedding from an inserted document to verify similarity scoring works\n5. Check similarity threshold: Orama defaults to ~0.8, may be filtering results\n6. Verify cosine distance: calculate actual similarity between query embedding and stored embeddings\n\nLong content doesn't prevent indexing but can affect embedding quality and similarity scores due to how embedding models handle truncation."
    }
  ]
}
```
