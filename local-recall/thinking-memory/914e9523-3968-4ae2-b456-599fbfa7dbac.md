---
id: 914e9523-3968-4ae2-b456-599fbfa7dbac
subject: >-
  The user wants me to remove the HTTP server approach and have the hooks call
  the database directly...
applies_to: global
occurred_at: '2025-12-03T10:06:01.544Z'
content_hash: ab3ef03a87ad8aa0
---
## Thought

The user wants me to remove the HTTP server approach and have the hooks call the database directly but still use the mutex for protection. This makes sense - if we have a proper in-process mutex, we don't need the HTTP server indirection.

However, there's a key issue: the mutex only works within a single process. If hooks run in separate processes from the daemon, they won't share the same mutex. The HTTP server was designed to centralize database access in one process (the daemon).

Let me think about this:
1. If hooks run as separate Node processes (which they do - they're spawned by Claude Code), they can't share an in-process mutex with the daemon
2. The file-based lock only protects the `sqliteVec.load()` call, not the actual operations

So there are two options:
1. Extend the file-based lock to cover entire database operations (not just loading)
2. Have hooks still communicate with the daemon via HTTP/IPC

Actually wait - looking at the hooks again, they're designed to use the DaemonClient to make HTTP requests. The mutex I'm adding is for the daemon process itself to serialize its internal operations.

But the user is saying they want to remove the HTTP method and have hooks call the DB directly. If we do that, we need a cross-process locking mechanism.

Let me re-read the user's message: "let's remove the http method though, and have the hooks call the db / vector db directly, but with the same mutex processes / protections in place"

I think the user wants:
1. Remove the HTTP server
2. Have hooks call the vector store directly
3. Use the same mutex protection (but it needs to be cross-process)

The simplest cross-process mutex is file-based locking. We already have `acquireLock` for sqlite-vec loading, but we need to extend it to cover all database operations.

Actually, a simpler approach is to use the same file lock but keep it held for the entire database operation, not just the sqlite-vec loading. 

I'll implement a robust file-based locking mechanism that ensures exclusive access across all processes. This will prevent race conditions and maintain data integrity when multiple hooks interact with the vector database simultaneously.

## Output

I understand. You want to:
1. Remove the HTTP server approach
2. Have hooks call the vector store directly
3. Use file-based locking that works across processes (not just in-process mutex)

The key issue is that the current mutex only works within a single process. For hooks (which run in separate processes), we need **file-based locking** that spans the entire database operation, not just sqlite-vec loading.

Let me update the approach to use file-based locking for all database operations:
