---
id: 45f0606c-6f0e-4113-ac53-77ab35d0ee95
subject: >-
  The searchByScope and getRelevantForSession tests are actually using the real
  memoryManager, which...
applies_to: global
occurred_at: '2025-12-01T18:01:41.389Z'
content_hash: 37211c8e790f1dd7
---
The searchByScope and getRelevantForSession tests are actually using the real memoryManager, which is created from MemoryManager(testDir). The vector store is mocked, but the memoryManager is real.

The issue is that the searchByScope method calls `this.memoryManager.listMemories()`, but the test is failing because it's using a mock. Wait, let me re-check the error message:

```
TypeError: this.memoryManager.listMemories is not a function
```

This suggests the memoryManager is not being passed correctly. Let me check how the SearchEngine is being constructed in the test - it's `searchEngine = new SearchEngine(memoryManager);` which looks correct.

Wait, the mock is for the vector store, not the memoryManager. The memoryManager is a real instance created from MemoryManager. The issue is that the SearchEngine expects a MemoryManager but somewhere the types might not be matching.

Let me look at the SearchEngine constructor again to see what's happening:

```typescript
constructor(memoryManager?: MemoryManager) {
  const config = getConfig();
  this.memoryManager = memoryManager ?? new MemoryManager(config.memoryDir);
}
```

Hmm, the constructor should work. The tests are passing `memoryManager` correctly. Let me see what's different...

Oh wait, the test is passing `searchEngine = new SearchEngine(memoryManager);` but the error says `this.memoryManager.listMemories is not a function`. This might be a different test failing - the one without the mock.

Actually looking at the error more carefully:
```
FAIL  tests/unit/core/search.test.ts > SearchEngine > searchByScope > should return all memories for a scope
TypeError: this.memoryManager.listMemories is not a function
```

The mock is applied at module level with `vi.mock(...)`. When the SearchEngine calls `getVectorStore()`, it gets the mocked version. 

I suspect the mock might be interfering with the actual memoryManager instance. The test creates a real memoryManager, but something in the mocking process is replacing or altering its methods. This could explain why `listMemories` is not recognized as a function, even though the original instance should have this method.

The problem likely stems from how the mocking is configured, potentially overwriting the entire memoryManager object or its prototype chain in a way that strips out its original methods.

I'll need to carefully examine the mocking setup to ensure it's only targeting the vector-store module and not inadvertently affecting the MemoryManager implementation.
