---
id: 996ce77a-a7c2-407d-9db9-1baf075f8497
subject: >-
  The user wants me to analyze the transcript and extract memories in JSON
  format. Let me go through...
applies_to: global
occurred_at: '2025-12-21T19:15:46.065Z'
content_hash: 7a24a790e02758af
---
## Thought

The user wants me to analyze the transcript and extract memories in JSON format. Let me go through the transcript carefully:

1. **What was learned?**
   - The mutex errors were caused by sqlite-vec's internal C++ `std::mutex` structures failing when multiple processes load the extension
   - SQLite was running in multi-thread mode (THREADSAFE=2) instead of serialized mode
   - Orama has a default similarity threshold of ~0.8 for vector search that filters out results below that threshold
   - The team migrated from sqlite-vec to Orama (pure JavaScript)

2. **What is now known?**
   - Hooks should not directly load sqlite-vec as it causes mutex errors across processes
   - Orama's similarity search parameter needs to be set to 0 to disable built-in threshold filtering
   - Vector indexes are persisted as JSON files (orama-episodic-index.json, orama-thinking-index.json)
   - The project uses Ollama for embeddings with nomic-embed-text model (768 dimensions)
   - Vector persistence/restore works correctly in Orama

3. **What is specific to this codebase?**
   - Local Recall uses both episodic and thinking memories with separate vector stores
   - The migration required updating VectorStore and ThinkingVectorStore classes
   - Search results are filtered by similarity threshold at the application level, not at the database level
   - The project had attempted HTTP daemon architecture but now uses pure JavaScript

4. **What problems were solved?**
   - Mutex error: `libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument`
   - Root cause: sqlite-vec's internal pthread mutexes failing when multiple processes load it
   - Solution: Migrate from sqlite-vec to Orama (pure JavaScript, no native dependencies)
   - Secondary issue: Orama's default similarity threshold was filtering out valid results (similarity ~0.77)
   - Solution: Set `similarity: 0` in search parameters to disable built-in threshold

I'll proceed with extracting memories systematically, focusing on key technical insights and problem-solving approaches. I'll create concise JSON representations that capture the essential technical details and resolution strategies.

## Output

```json
{
  "memories": [
    {
      "subject": "Mutex errors caused by sqlite-vec in hook processes, not SQLite locking",
      "keywords": ["sqlite-vec", "mutex", "hook", "process", "c++", "pthread", "error", "native"],
      "applies_to": "global",
      "content": "The mutex error `libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument` was not caused by SQLite database locks or file-based mutex coordination. Instead, it came from sqlite-vec's internal C++ `std::mutex` structures that are created at the process level. When the hook process loads sqlite-vec, it creates process-local mutex state, and these internal mutexes can fail with \"Invalid argument\" when processes try to use them across process boundaries or during cleanup. This is a fundamental architectural issue with using native C++ extensions in short-lived hook processes."
    },
    {
      "subject": "SQLite was running in multi-thread mode (THREADSAFE=2) instead of serialized mode",
      "keywords": ["sqlite", "threading", "mode", "threadsafe", "serialized", "multi-thread"],
      "applies_to": "global",
      "content": "The SQLite connection was configured in multi-thread mode (THREADSAFE=2), not serialized mode (THREADSAFE=1). In multi-thread mode, SQLite assumes each database connection is accessed by only one thread at a time. Serialized mode (THREADSAFE=1) fully serializes all operations internally. The project's file-based mutex coordination (`withDbMutex`) was insufficient because it only coordinated database access, not the internal pthread mutexes used by sqlite-vec."
    },
    {
      "subject": "Migrated from sqlite-vec to Orama to eliminate native C++ dependencies",
      "keywords": ["migration", "sqlite-vec", "orama", "vector", "search", "pure javascript"],
      "applies_to": "global",
      "content": "The project successfully migrated from sqlite-vec (native C++ SQLite extension) to Orama (pure JavaScript vector search library). This eliminates the mutex errors entirely since Orama is pure JavaScript with no native dependencies. The migration involved:\n1. Replacing `src/core/vector-store.ts` to use Orama's `create()`, `insert()`, `search()` APIs\n2. Replacing `src/core/thinking-vector-store.ts` similarly\n3. Removing `better-sqlite3` and `sqlite-vec` from package.json\n4. Deleting `src/utils/database.ts` (mutex coordination no longer needed)\n5. Updating gitignore to track `orama-episodic-index.json` and `orama-thinking-index.json` as gitignored files\n6. Vector indexes are persisted as JSON files using `@orama/plugin-data-persistence`\n7. Embeddings still generated via Ollama with nomic-embed-text model (768 dimensions)"
    },
    {
      "subject": "Orama default similarity threshold (~0.8) filters out valid results",
      "keywords": ["orama", "similarity", "threshold", "vector", "search", "filter"],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "Orama has a default similarity threshold of approximately 0.8 for vector search. This means results with similarity scores below ~0.8 are filtered out and not returned. For Local Recall, embeddings with similarity ~0.77 were being filtered incorrectly. The fix is to set `similarity: 0` in the search parameters to disable Orama's built-in threshold filtering. The application handles its own similarity threshold filtering (configured via `episodicMinSimilarity` and `thinkingMinSimilarity` environment variables, default 0.5). This allows the vector store to return all results and let the application layer apply its own threshold logic."
    },
    {
      "subject": "Vector persistence/restore works correctly in Orama with JSON format",
      "keywords": ["orama", "persist", "restore", "json", "index", "vector"],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "Orama's JSON persistence and restore works correctly with vector data. The `@orama/plugin-data-persistence` plugin handles serialization and deserialization of both schema and vector embeddings. The index files are self-contained JSON that can be loaded back into memory. Schema information is preserved during persist/restore cycles. Vector dimensions (384 for BGE-small embeddings, 768 for nomic-embed-text) are maintained correctly through the persistence layer."
    },
    {
      "subject": "HTTP daemon architecture was previously attempted but replaced with pure JavaScript",
      "keywords": ["architecture", "daemon", "http", "hooks", "orama", "pure javascript"],
      "applies_to": "global",
      "content": "The project previously attempted to implement an HTTP daemon architecture to isolate sqlite-vec from hook processes (daemon-client.ts and http-server.ts were deleted). This was meant to avoid the mutex issue by having hooks communicate with a central daemon process. However, the simpler solution was to replace sqlite-vec entirely with Orama (pure JavaScript), which eliminated the need for process isolation. Hooks now directly instantiate and use the Orama vector store without any inter-process communication or daemon coordination."
    }
  ]
}
```
