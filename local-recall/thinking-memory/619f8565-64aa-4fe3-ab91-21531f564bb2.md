---
id: 619f8565-64aa-4fe3-ab91-21531f564bb2
subject: >-
  The user is proposing a significant design change: 1. **Process the whole
  transcript history** - No...
applies_to: global
occurred_at: '2025-11-29T20:58:50.510Z'
content_hash: 168b8c9c7e145844
---
## Thought

The user is proposing a significant design change:

1. **Process the whole transcript history** - No time window filtering
2. **Idempotent memory creation** - Same content/context should result in the same memory (or be recognized as duplicate)
3. **Timestamped memories** - For episodic framing
4. **Immutable memories** - No update/delete via the system, only manual user removal

This is a philosophical shift from "mutable knowledge base" to "episodic memory log" - more like how human memory actually works. Events are recorded, not overwritten.

This raises some questions I should discuss with them:

1. **Idempotency mechanism** - How do we determine "same memory"?
   - Hash of content?
   - Subject + keywords match?
   - Semantic similarity?

2. **What happens to the update/delete MCP tools?** - Remove them? Make them user-only?

3. **Deduplication strategy** - If we process the whole transcript every time, we need to not create duplicates. Options:
   - Content hash stored in the memory
   - Check existing memories before creating
   - Use deterministic IDs based on content

4. **Episodic vs semantic** - Are we keeping both types? Or shifting to purely episodic?

Let me engage with them on these decisions.

## Output

That's a meaningful shift - from "mutable knowledge base" to "episodic memory log". More like how memory actually works.

A few things to decide:

**1. Idempotency mechanism** - How do we determine "same memory"?
- Content hash? (exact match)
- Subject + keywords overlap above threshold?
- Deterministic ID derived from content?

**2. MCP tools** - Currently we expose `memory_update` and `memory_delete`. Options:
- Remove them entirely
- Keep them but only for user-initiated actions (not agent-initiated)
- Deprecate but leave for backwards compat

**3. Deduplication timing** - Check before creating:
- Hash-based lookup in index (fast)
- Or just let duplicates exist and handle at read time?

**4. Timestamp semantics** - What does the timestamp represent?
- When the memory was created?
- When the event/conversation occurred?
- Both? (`created_at` vs `occurred_at`)

My instinct:
- Use a content hash as a deduplication key (stored in frontmatter)
- Keep `created_at` for when memory was written, add `occurred_at` for the conversation timestamp
- Remove `memory_update`, keep `memory_delete` as user-only (agents can't call it)

What's your take?
