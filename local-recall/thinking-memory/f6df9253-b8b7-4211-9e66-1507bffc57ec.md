---
id: f6df9253-b8b7-4211-9e66-1507bffc57ec
subject: >-
  Now I have a comprehensive view of the hooks. Let me provide a good summary
  for the user.
applies_to: global
occurred_at: '2025-11-29T22:50:29.350Z'
content_hash: 7bdcdfef7f90592c
---
## Thought

Now I have a comprehensive view of the hooks. Let me provide a good summary for the user.

## Output

## Local Recall Hooks Overview

This project has **three hooks** that integrate with Claude Code to provide persistent memory across sessions:

### 1. SessionStart Hook (`src/hooks/session-start.ts`)

**Triggered:** When a Claude Code session begins

**What it does:**
- Loads the memory index from `local-recall/index.json`
- Searches for relevant memories based on context (files, areas)
- Outputs memories to stdout, which gets injected into Claude's context
- Shows index stats (total memories, keywords, last indexed time)

**Timeout:** 30 seconds

**Key behaviors:**
- Uses `cwd` from stdin or falls back to `CLAUDE_PROJECT_DIR` env var
- Can filter by `LOCAL_RECALL_CONTEXT_FILES` and `LOCAL_RECALL_CONTEXT_AREA` env vars
- Always exits 0 to avoid blocking sessions, even on errors

---

### 2. UserPromptSubmit Hook (`src/hooks/user-prompt-submit.ts`)

**Triggered:** When user submits a prompt, before Claude processes it

**What it does:**
1. Extracts keywords from the user's prompt using `keyword-extractor`
2. Filters keywords (>2 chars, max 10)
3. Searches memory index with fuzzy matching
4. Returns up to 5 relevant memories with match scores

**Timeout:** 30 seconds

**Example output:**
```
# Local Recall: Relevant Memories
Found 3 memories related to your query.

[Memory content]
*Match score: 85% | Keywords: typescript, config*
```

---

### 3. Stop Hook (`src/hooks/stop.ts`)

**Triggered:** When Claude stops processing (end of response)

**What it does:**
1. Reads the transcript file (JSONL format from `transcript_path`)
2. Parses transcript using `parseTranscriptForMemories()` to find memory-worthy content
3. Creates new memory files via `MemoryManager`
4. Refreshes the index

**Timeout:** 60 seconds (longer because it writes files)

**Key behaviors:**
- Logs created memory count to stderr
- Rebuilds the index after creating memories
- This is where new memories get persisted

---

### Hook Configuration (`hooks.json`)

All hooks use `${CLAUDE_PLUGIN_ROOT}` to reference bundled scripts, making the plugin portable:

```json
{
  "hooks": {
    "SessionStart": [{ "command": "node ${CLAUDE_PLUGIN_ROOT}/scripts/hooks/session-start.js" }],
    "UserPromptSubmit": [{ "command": "node ${CLAUDE_PLUGIN_ROOT}/scripts/hooks/user-prompt-submit.js" }],
    "Stop": [{ "command": "node ${CLAUDE_PLUGIN_ROOT}/scripts/hooks/stop.js" }]
  }
}
```

### Data Flow

```
SessionStart → Load existing memories into context
     ↓
UserPromptSubmit → Add relevant memories based on user query
     ↓
Claude processes request
     ↓
Stop → Parse transcript, create new memories
```
