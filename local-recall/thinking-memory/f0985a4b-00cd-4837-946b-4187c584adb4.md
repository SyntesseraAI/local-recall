---
id: f0985a4b-00cd-4837-946b-4187c584adb4
subject: >-
  The user has provided a condensed transcript of a Claude Code session where
  they were investigating...
applies_to: global
occurred_at: '2025-12-21T18:18:26.498Z'
content_hash: dc329eb17564da3f
---
## Thought

The user has provided a condensed transcript of a Claude Code session where they were investigating and fixing a mutex error issue with sqlite-vec, then migrating the project to use Orama instead.

Let me analyze what was learned and discovered:

1. **The Problem**: sqlite-vec was causing mutex lock failures ("Invalid argument") even though the code intended to use read-only operations. The issue was that sqlite-vec uses internal C++ `std::mutex` structures that fail when multiple processes load the extension.

2. **Root Cause Analysis**: 
   - SQLite was running in multi-thread mode (THREADSAFE=2), not serialized mode (THREADSAFE=1)
   - sqlite-vec's internal C++ mutexes were failing at the native code level, not at the SQLite database level
   - The file-based locking approach with `withDbMutex` couldn't prevent these native mutex failures
   - The error was: "libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument"

3. **The Solution**: Migrate from sqlite-vec to Orama
   - Orama is pure JavaScript with no native dependencies
   - No mutex issues since it doesn't use C++ threading primitives
   - Uses Ollama for embeddings (same as before)
   - Persists to JSON files instead of SQLite

4. **Implementation Details**:
   - Removed `better-sqlite3` and `sqlite-vec` dependencies
   - Removed `src/utils/database.ts` which had the mutex locking logic
   - Rewrote `src/core/vector-store.ts` to use Orama
   - Rewrote `src/core/thinking-vector-store.ts` to use Orama
   - Updated gitignore patterns for `orama-*.json` files
   - Fixed a critical issue with Orama's default similarity threshold (0.8) - set it to 0 to disable and use custom filtering
   - Vectors are stored as 384-dimensional arrays in Orama

I'll focus on the technical nuances of the vector storage and search mechanism. Orama's similarity search has a default threshold that was inadvertently filtering out potentially relevant results. By setting the similarity parameter to 0, we've gained more granular control over result filtering. The 384-dimensional vector representation remains consistent during persistence, ensuring data integrity. This approach allows for precise vector comparisons without performance overhead, even with longer content vectors.

The project maintains two distinct memory stores - episodic and thinking - both leveraging this robust vector storage approach. This design enables flexible and efficient semantic search capabilities across different memory contexts.

The architecture has evolved from an initially planned HTTP daemon to a direct, streamlined implementation. Hooks like session-start.ts and user-prompt-submit.ts now directly instantiate search engines, simplifying the overall system design and reducing unnecessary architectural complexity.

## Output

```json
{
  "memories": [
    {
      "subject": "sqlite-vec mutex error was caused by native C++ mutex state, not SQLite locking",
      "keywords": ["sqlite-vec", "mutex", "error", "threading", "native-code", "debugging"],
      "applies_to": "global",
      "content": "When sqlite-vec caused 'libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument' errors, the root cause was NOT the file-based locking approach - it was sqlite-vec's internal C++ `std::mutex` structures failing at the native code level when loaded by multiple processes. The file-based `withDbMutex` locking couldn't prevent these native pthread mutex failures. This led to the migration to Orama (pure JavaScript) to eliminate native dependencies entirely."
    },
    {
      "subject": "SQLite was running in multi-thread mode (THREADSAFE=2) not serialized mode",
      "keywords": ["sqlite", "threading", "THREADSAFE", "serialized-mode", "configuration"],
      "applies_to": "global",
      "content": "Discovered that better-sqlite3 was running SQLite in multi-thread mode (THREADSAFE=2) rather than serialized mode (THREADSAFE=1). Multi-thread mode (`THREADSAFE=2`) assumes each database connection is used by only one thread at a time. This contributed to the mutex issues. The proper fix was to eliminate SQLite entirely in favor of pure JavaScript vector storage."
    },
    {
      "subject": "Migrated from sqlite-vec to Orama for vector search",
      "keywords": ["orama", "migration", "vector-search", "pure-javascript", "no-native-deps"],
      "applies_to": "global",
      "content": "Completed migration from sqlite-vec to Orama. Removed dependencies: `better-sqlite3`, `sqlite-vec`, `@types/better-sqlite3`. Added: `@orama/orama`, `@orama/plugin-data-persistence`. Modified: `src/core/vector-store.ts` and `src/core/thinking-vector-store.ts` to use Orama. Removed: `src/utils/database.ts` (mutex utilities). Benefits: pure JavaScript implementation with no native C++ dependencies, eliminates pthread mutex failures, cleaner architecture."
    },
    {
      "subject": "Orama has default similarity threshold (~0.8) that filters valid search results",
      "keywords": ["orama", "similarity-threshold", "vector-search", "search-parameters"],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "When implementing Orama vector search, discovered that Orama applies a built-in similarity threshold (~0.8) by default. Results with similarity scores below this (like 0.77) were being filtered out even though they were legitimate matches. Fix: set `similarity: 0` in the search parameters to disable Orama's threshold filtering, then handle threshold filtering in the application layer. This allows for more flexible similarity control and better results for semantic search."
    },
    {
      "subject": "Vector schema dimensions (384) are preserved during Orama persist/restore",
      "keywords": ["orama", "persist", "restore", "schema", "vector-dimensions", "384"],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "Orama correctly preserves vector schema with `vector[384]` dimensions when persisting to JSON and restoring. The issue with search not working after restore was NOT due to schema loss, but rather the default similarity threshold filtering. Verified that persist/restore works correctly with proper schema definition and disabled similarity threshold in search parameters."
    }
  ]
}
```
