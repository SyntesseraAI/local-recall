---
id: 331b717d-321a-464c-b979-04bf2f152dd5
subject: >-
  The user is asking me to extract memories from a transcript about migrating
  from sqlite-vec to...
applies_to: global
occurred_at: '2025-12-21T19:16:54.255Z'
content_hash: 8c33654800588b4c
---
## Thought

The user is asking me to extract memories from a transcript about migrating from sqlite-vec to Orama. This is the [LOCAL_RECALL_INTERNAL] memory extraction task.

Let me analyze what was learned, discovered, and solved during this session:

1. **The Core Problem**: sqlite-vec was causing mutex errors because it uses internal C++ std::mutex structures that fail when multiple processes load the extension, even with file-based locking. The mutex error occurs at the native code level, not the SQLite level.

2. **SQLite Threading Mode Discovery**: The team discovered that SQLite was running in multi-thread mode (THREADSAFE=2), not serialized mode (THREADSAFE=1). In multi-thread mode, each connection must be used by only one thread at a time.

3. **Why HTTP Daemon Architecture Failed**: The original architecture planned to use an HTTP daemon client to avoid loading sqlite-vec in hook processes, but the daemon files were deleted. The hooks were directly instantiating SearchEngine and ThinkingSearchEngine which loaded the problematic extension.

4. **Migration to Orama**: Orama is a pure JavaScript vector database that:
   - Has no native dependencies
   - Persists to JSON files
   - Uses cosine distance for similarity
   - Has a default similarity threshold (~0.8) that can be set to 0 to disable

5. **Key Technical Discovery - Vector Search Issue**: The vector search was failing because:
   - Orama has a default similarity threshold of ~0.8
   - The embeddings for different queries had similarity ~0.77 to the stored vectors
   - This caused them to be filtered out
   - Solution: Set `similarity: 0` to disable Orama's threshold and handle filtering manually

6. **Persist/Restore Works**: Orama's persist/restore functionality works correctly with vector embeddings, preserving the 384-dimensional vectors.

7. **Files Removed**: `src/utils/database.ts` is no longer needed in the new architecture


I've updated the project dependencies, removing SQLite-related packages and integrating Orama. The team meticulously tested the new implementation, systematically debugging by examining content lengths, query types, and embedding characteristics. They discovered that setting the similarity threshold to zero was crucial for accurate vector search, allowing more flexible filtering of search results. This approach resolved the previous limitations with sqlite-vec and provided a more robust vector search solution.

## Output

```json
{
  "memories": [
    {
      "subject": "sqlite-vec mutex errors caused by C++ native code in hook processes",
      "keywords": [
        "sqlite-vec",
        "mutex error",
        "native code",
        "hooks",
        "threading",
        "process isolation"
      ],
      "applies_to": "global",
      "content": "## Problem\nsqlite-vec extension causes mutex errors: `libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument`\n\n## Root Cause\nsqlite-vec uses internal C++ `std::mutex` structures for vector operations that fail when:\n1. Multiple processes load the extension\n2. File-based locking (withDbMutex) doesn't protect against pthread mutex failures\n3. Mutex errors occur at the native code level, not SQLite's database lock level\n\n## Why File-Based Locking Failed\nThe file-based mutex serializes database access across processes, but sqlite-vec's internal C++ mutexes are process-local and independent. When hook processes load sqlite-vec, they create separate mutex state that can fail with \"Invalid argument\".\n\n## Solution\nMigrate to pure JavaScript vector database (Orama) with no native dependencies."
    },
    {
      "subject": "SQLite threading mode was multi-thread, not serialized",
      "keywords": [
        "sqlite",
        "threading mode",
        "THREADSAFE",
        "serialized mode",
        "multi-thread mode"
      ],
      "applies_to": "global",
      "content": "## Discovery\nSQLite was running in multi-thread mode (THREADSAFE=2), not serialized mode (THREADSAFE=1).\n\n## Threading Modes\n| Mode | Value | Behavior |\n|------|-------|----------|\n| Single-thread | 0 | No mutexes, not thread-safe |\n| Serialized | 1 | Fully thread-safe, all operations serialized internally |\n| Multi-thread | 2 | Safe only if each connection used by one thread at a time |\n\n## Impact\nIn multi-thread mode, SQLite doesn't provide full process-level synchronization. This requires external mutex management (via file-based locks), which sqlite-vec's native mutexes bypassed."
    },
    {
      "subject": "Orama default similarity threshold of 0.8 filters out valid results",
      "keywords": [
        "orama",
        "similarity threshold",
        "vector search",
        "cosine distance",
        "embedding"
      ],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "## Problem\nOrama vector search was returning 0 results even when embeddings were correctly stored and indexed.\n\n## Root Cause\nOrama has a default similarity threshold of approximately 0.8. When querying:\n- Embeddings had cosine similarity ~0.77 to stored vectors\n- Results were filtered out by Orama's threshold\n- This occurred even though the embeddings were semantically similar\n\n## Solution\nSet `similarity: 0` in search parameters to disable Orama's internal threshold filtering. LocalRecall implements its own similarity filtering at application level, so Orama's threshold is redundant and blocks valid results.\n\n## Implementation\nBoth `vector-store.ts` and `thinking-vector-store.ts` search methods must include:\n```typescript\nsimilarity: 0  // Disable Orama's threshold, use our own filtering\n```"
    },
    {
      "subject": "Orama persist/restore correctly preserves 384-dimensional vector embeddings",
      "keywords": [
        "orama",
        "persist",
        "restore",
        "vector embedding",
        "json"
      ],
      "applies_to": "global",
      "content": "## Finding\nOrama's persist/restore functionality works correctly with vector embeddings. The persisted JSON files maintain:\n- Complete 384-dimensional vector arrays\n- Correct schema with `vector[384]` type definition\n- Full document metadata and embeddings\n\n## Verification\nTested multiple scenarios:\n1. Fresh persist/restore cycle preserves vectors\n2. Schema is correctly restored from JSON\n3. Vector search works identically before and after persist/restore\n\n## Implementation Details\n- Vectors are stored in persisted JSON as arrays of numbers\n- Schema includes `vector: 'vector[384]'` field definition\n- Index restoration happens automatically on `restore()` call"
    },
    {
      "subject": "HTTP daemon architecture was planned but removed before this session",
      "keywords": [
        "architecture",
        "http daemon",
        "daemon client",
        "process isolation",
        "removed"
      ],
      "applies_to": "global",
      "content": "## Context\nThe original architecture planned to use an HTTP daemon to avoid loading sqlite-vec in hook processes:\n- `daemon-client.ts` - Hook-side client\n- `http-server.ts` - Background daemon for vector operations\n- Hooks would call HTTP client instead of directly instantiating SearchEngine\n\n## What Happened\nThese files were deleted before this session, leaving hooks to directly instantiate SearchEngine and ThinkingSearchEngine. This forced hooks to load sqlite-vec directly, causing the mutex errors.\n\n## Lesson\nPure JavaScript solutions (like Orama) are better than trying to isolate native C++ code via processes. No daemon complexity needed with Orama."
    },
    {
      "subject": "Orama is pure JavaScript with no native dependencies",
      "keywords": [
        "orama",
        "pure javascript",
        "no native dependencies",
        "vector search",
        "migration"
      ],
      "applies_to": "global",
      "content": "## Orama Advantages\n1. **Pure JavaScript** - No C++ native bindings\n2. **No mutex issues** - No threading concerns across processes\n3. **JSON persistence** - Persists to JSON files, easily version-controllable\n4. **Simple integration** - Direct import, no process isolation needed\n5. **Embedding support** - Works with external embeddings (Ollama)\n\n## Dependencies Added\n- `@orama/orama` - Core vector search\n- `@orama/plugin-data-persistence` - JSON persistence\n\n## Dependencies Removed\n- `better-sqlite3`\n- `sqlite-vec`\n- `@types/better-sqlite3`\n\n## Result\nHooks can now directly call VectorStore without process isolation concerns."
    },
    {
      "subject": "Systematic debugging process for isolating vector search failures",
      "keywords": [
        "debugging",
        "vector search",
        "isolation",
        "test methodology",
        "root cause analysis"
      ],
      "applies_to": "global",
      "content": "## Debugging Approach\n1. **Test in fresh database** - Confirms the issue is reproducible\n2. **Test with simple data** - Isolates whether it's data-specific\n3. **Test with actual memory data** - Ensures issue appears with real data\n4. **Trace execution flow** - Replicate the exact VectorStore logic in isolation\n5. **Test different variables** - Vary content length, query type, embedding\n6. **Check numerical values** - Compare embeddings and similarity scores\n7. **Test with known values** - Use exact embeddings to verify system works\n\n## Key Test Case\nTesting with long content (actual memory files) exposed the similarity threshold issue that didn't appear with simple test data."
    },
    {
      "subject": "database.ts file is no longer needed after Orama migration",
      "keywords": [
        "database.ts",
        "removed",
        "migration",
        "cleanup"
      ],
      "applies_to": "file:src/utils/database.ts",
      "content": "## Status\nThe `src/utils/database.ts` file containing SQLite mutex utilities is now obsolete and was removed during the Orama migration.\n\n## Why It's No Longer Needed\n1. Orama uses pure JavaScript with no native code\n2. No threading/process isolation issues to manage\n3. No SQLite connections requiring mutex protection\n4. File-based locking (withDbMutex, openDatabase) are unnecessary\n\n## References\nThe file was imported only in vector-store.ts and thinking-vector-store.ts, which now use Orama directly."
    }
  ]
}
```
