---
id: f68028a6-a6e7-4be4-9556-3eb2ed37558a
subject: >-
  I see - the config is cached and uses `process.env['LOCAL_RECALL_DIR']` if
  set. The test sets...
applies_to: global
occurred_at: '2025-12-03T09:34:13.741Z'
content_hash: 152e3b16515b50ae
---
## Thought

I see - the config is cached and uses `process.env['LOCAL_RECALL_DIR']` if set. The test sets `process.env['LOCAL_RECALL_DIR'] = testDir` before creating the managers.

The issue is likely that:
1. Test sets `process.env['LOCAL_RECALL_DIR'] = testDir`
2. Test creates `MemoryManager(testDir)` - uses testDir explicitly
3. Test creates `SearchEngine(memoryManager)` - legacy constructor
4. SearchEngine.search() calls `getVectorStore({ readonly: this.readonly })` with no baseDir
5. VectorStore constructor uses `config.memoryDir` which comes from `getConfig()`
6. But `getConfig()` uses the cached config which may have been initialized before the test set the env var

Actually wait, the tests do call `resetVectorStore()` before each test, and each test sets the env var... but the config is a singleton that may have been loaded with a different value.

Let me check - when `getVectorStore({ readonly: true })` is called, it creates a new VectorStore with `baseDir: undefined`, which means VectorStore constructor does `this.baseDir = options.baseDir ?? config.memoryDir`.

If the config was loaded before the env var was set, or if the cached config hasn't been updated, the VectorStore might be using a different directory.

Actually, looking more closely at the code flow:
1. Test: `process.env['LOCAL_RECALL_DIR'] = testDir`2. Test: `memoryManager = new MemoryManager(testDir)` - explicitly passes testDir3. Test: `searchEngine = new SearchEngine(memoryManager)` - passes memoryManager
4. SearchEngine constructor: Uses the memoryManager but also has `this.readonly = false`
5. When `searchEngine.search()` is called, it does `getVectorStore({ readonly: this.readonly })` with no baseDir


6. VectorStore constructor: `this.baseDir = options.baseDir ?? config.memoryDir`
7. If `config.memoryDir` wasn't updated to `testDir`, the VectorStore uses the wrong directory!

I realize the core problem is a configuration synchronization issue. The VectorStore retrieval mechanism doesn't consistently propagate the test directory across different method calls. When searching, it falls back to the potentially stale configuration, which might not reflect the current test environment's intended directory path.

The mechanism breaks down because the search operation doesn't explicitly pass the base directory, instead relying on a potentially outdated global configuration. This subtle discrepancy means tests could inadvertently use incorrect storage locations, leading to unpredictable behavior.

I need to ensure the base directory context is consistently maintained throughout different method invocations, particularly between memory management and search operations. The solution requires explicitly passing the base directory context during vector store retrieval.

The previous singleton implementation inadvertently concealed a potential configuration mismatch by always returning the initially created vector store instance. This meant that subsequent calls would ignore changes in base directory or configuration settings, potentially leading to unexpected behavior in test scenarios.

The key observation is that the vector store initialization needs to respect the specific base directory context of each method call, rather than relying on a static, globally shared instance.

To resolve this, I'll modify the SearchEngine to explicitly pass the base directory from the MemoryManager, ensuring each vector store is created with the correct configuration context.

## Output

I found the issue! The `SearchEngine.search()` method calls `getVectorStore({ readonly: this.readonly })` without passing the `baseDir`, so it uses `config.memoryDir` from the global config instead of the same directory as the `MemoryManager`.

The old singleton pattern masked this - the first call to `getVectorStore()` would set the baseDir, and subsequent calls returned the same instance. With ephemeral instances, each call needs the correct baseDir.

Let me fix the `SearchEngine` to pass the correct baseDir:
