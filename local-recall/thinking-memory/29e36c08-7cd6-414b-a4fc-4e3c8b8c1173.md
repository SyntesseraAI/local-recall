---
id: 29e36c08-7cd6-414b-a4fc-4e3c8b8c1173
subject: Now I have a clear picture of the current architecture. Let me analyze the...
applies_to: global
occurred_at: '2025-12-15T14:34:21.423Z'
content_hash: b6912ba7675ff040
---
## Thought

Now I have a clear picture of the current architecture. Let me analyze the isolation/cross-communication situation:

**Current Architecture Issues:**

1. **Multiple MCP servers per project**: Each Claude Code instance spawns its own MCP server process. If you have 2 Claude windows open in the same project, you have 2 MCP servers running.

2. **Shared files without locking**:
   - `orama-episodic-index.json` - Multiple processes can write to this
   - `orama-thinking-index.json` - Same issue
   - `processed-log.jsonl` - Same issue
   - Memory files in `episodic-memory/` and `thinking-memory/`

3. **No cross-process coordination**:
   - Each MCP server runs its own daemon loop (transcript processing every 5 minutes)
   - Multiple daemons could process the same transcript simultaneously
   - Multiple processes could write to the same index files without coordination

4. **Race conditions possible**:
   - Process A reads index, Process B reads index
   - Process A adds memory, writes index
   - Process B adds memory, writes index (overwrites A's changes)

**What can go wrong:**
- Duplicate memory extraction (same transcript processed by multiple daemons)
- Lost index updates (concurrent writes)
- Corrupted index files (partial writes)
- Duplicate log entries in recall.log (as mentioned in the memory)

**Potential solutions:**

1. **File locking**: Add file locks when writing to indexes
2. **Single daemon mode**: Only one MCP server runs the daemon, others are read-only
3. **Separate MCP server process**: Run one long-lived daemon that multiple Claude instances connect to via TCP/socket
4. **Leader election**: Use a lock file to elect one process as the "daemon leader"

Let me explain this to the user clearly.

## Output

**Short answer: Yes, and it's a problem.**

Here's what happens with multiple instances:

## Current Issues

| Resource | Problem |
|----------|---------|
| `orama-episodic-index.json` | Multiple processes write without coordination â†’ lost updates |
| `orama-thinking-index.json` | Same issue |
| `processed-log.jsonl` | Same transcript could be processed by multiple daemons |
| `recall.log` | Duplicate entries (you've seen this) |

Each Claude Code instance spawns its own MCP server, and each runs the daemon loop independently (every 5 minutes). There's no coordination.

## Potential Solutions

**1. Leader Election (simplest)**
- Use a lock file to elect one MCP server as the "daemon leader"
- Other instances run tools but skip the daemon loop
- Leader writes, others read

**2. Single Shared Daemon (cleanest)**
- One long-running process that handles all transcript processing
- MCP servers connect via TCP/socket instead of each running their own daemon
- Requires architecture change from stdio to networked transport

**3. File Locking**
- Add advisory locks when writing indexes
- Prevents concurrent writes but adds complexity and potential deadlocks

**4. Disable Daemon in MCP Server**
- Run daemon as a separate background service (`local-recall daemon`)
- MCP servers only provide read/write tools, no background processing

Which approach interests you? Option 1 is the quickest fix, Option 2 is the cleanest long-term solution.
