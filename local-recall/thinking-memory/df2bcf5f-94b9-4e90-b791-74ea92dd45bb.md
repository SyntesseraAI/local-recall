---
id: df2bcf5f-94b9-4e90-b791-74ea92dd45bb
subject: >-
  The user is asking me to extract memories from the transcript. Let me analyze
  what happened: ## Key...
applies_to: global
occurred_at: '2025-12-03T11:21:11.225Z'
content_hash: a6d9b8b384ae3495
---
## Thought

The user is asking me to extract memories from the transcript. Let me analyze what happened:

## Key Findings from the Transcript:

1. **The Problem**: Users were getting mutex lock errors when sqlite-vec tried to load in hooks, even though it should have been read-only. This was because:
   - sqlite-vec uses internal C++ `std::mutex` structures
   - When multiple processes load the extension, these mutexes fail
   - The error occurs at native code level, not SQLite database level
   - SQLite was running in multi-thread mode (THREADSAFE=2), not serialized mode

2. **The Root Cause**: 
   - sqlite-vec's internal C++ mutexes can fail with "Invalid argument" when processes exit or cleanup happens
   - The file-based locking (`withDbMutex`) was serializing access, but that doesn't help with native C++ mutexes
   - Multi-thread mode (THREADSAFE=2) means SQLite assumes each connection is used by only one thread at a time

3. **The Solution**:
   - Migrated from sqlite-vec to Orama (pure JavaScript vector database)
   - Removed `better-sqlite3` and `sqlite-vec` dependencies
   - Removed `database.ts` which had the file-based mutex locking
   - Updated both episodic and thinking vector stores to use Orama
   - Key technical fix: Set `similarity: 0` in Orama search to disable default 0.8 threshold (they handle their own filtering)

4. **Orama Specifics**:
   - Uses persistent JSON-based indexes (`orama-episodic.json`, `orama-thinking.json`)
   - Supports vector search with configurable dimensions
   - Default similarity threshold of ~0.8 can filter out valid results - need to disable
   - Works with fastembed embeddings (same as before)

5. **Key Discovery**: 
   - Long document content with embeddings caused vector search to return 0 results
   - Orama's default similarity threshold of 0.8 was filtering out results with ~0.77 similarity
   - Disabling the threshold by setting `similarity: 0` resolved the search issue

6. **Testing Validation**:
   - Vector persistence and restoration confirmed working
   - Precise schema configuration with `vector[384]` dimensions critical
   - Memory synchronization process functioning as expected

I'll proceed with memory extractions based on these insights.

## Output

```json
{
  "memories": [
    {
      "subject": "sqlite-vec mutex errors caused by C++ pthread mutexes failing across processes",
      "keywords": ["sqlite-vec", "mutex", "threading", "native extension", "hook errors", "process isolation"],
      "applies_to": "global",
      "content": "The \"mutex lock failed: Invalid argument\" errors were NOT coming from SQLite's database locks, but from sqlite-vec's internal C++ `std::mutex` structures. These pthread mutexes fail when:\n\n1. The hook process loads the extension in process-local memory\n2. Internal C++ mutex state becomes invalid during process cleanup\n3. Multiple processes try to initialize the same C++ structures\n\nThis happens regardless of file-based locking or SQLite thread mode because it's at the native C++ level, not the SQLite level. Even with multi-process synchronization at the SQLite level, the native extension's internal mutexes remain unsafe for concurrent process access."
    },
    {
      "subject": "SQLite threading mode: THREADSAFE=2 (multi-thread) vs THREADSAFE=1 (serialized)",
      "keywords": ["sqlite", "threading", "threadsafe", "multi-thread mode", "serialized mode", "better-sqlite3"],
      "applies_to": "global",
      "content": "SQLite THREADSAFE values:\n- 0: Single-thread (no mutexes, not thread-safe at all)\n- 1: Serialized (fully thread-safe, all operations serialized internally by SQLite)\n- 2: Multi-thread (safe only if each connection used by one thread at a time)\n\nLocal Recall was using THREADSAFE=2 (multi-thread mode), which means SQLite doesn't fully serialize access internally. This is fine for multi-threaded apps but doesn't prevent issues with extensions like sqlite-vec that have their own C++ mutexes."
    },
    {
      "subject": "Migrated from sqlite-vec to Orama for vector search - pure JavaScript replacement",
      "keywords": ["orama", "vector search", "migration", "javascript", "no native extensions", "json persistence"],
      "applies_to": "global",
      "content": "Successfully migrated from sqlite-vec (native C++ extension) to Orama (pure JavaScript vector database).\n\n**Removed dependencies:**\n- better-sqlite3\n- sqlite-vec\n- @types/better-sqlite3\n- src/utils/database.ts (file-based mutex locking)\n\n**Added packages:**\n- @orama/orama\n- @orama/plugin-data-persistence\n\n**Changed files:**\n- src/core/vector-store.ts\n- src/core/thinking-vector-store.ts\n- src/utils/gitignore.ts (added orama-*.json patterns)\n\nThis eliminates the entire class of \"native extension mutex errors\" because Orama is pure JavaScript."
    },
    {
      "subject": "Orama vector search default similarity threshold of ~0.8 filters valid results",
      "keywords": ["orama", "similarity threshold", "vector search", "filtering", "search parameters"],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "Orama has a default similarity threshold of approximately 0.8 that automatically filters results. When searching for embeddings with similarity ~0.77, Orama returns 0 results even though the embeddings are in the index.\n\n**Fix:** Set `similarity: 0` in Orama search parameters to disable the built-in threshold. Local Recall handles its own similarity filtering with `minSimilarity` option, so Orama's threshold should be disabled.\n\nApplies to both episodic and thinking vector stores."
    },
    {
      "subject": "Orama vector persistence uses JSON format with schema preservation",
      "keywords": ["orama", "persistence", "json", "vector storage", "schema"],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "Orama persists vector indexes to JSON files (e.g., `orama-episodic.json`, `orama-thinking.json`). Key observations:\n\n1. Vectors are stored with full precision and can be restored correctly\n2. Schema must be explicitly specified with `vector[384]` dimensions when creating database\n3. Persist/restore cycle works correctly with proper schema\n4. Long document content (1000+ chars) works fine with vector search once similarity threshold is disabled\n5. Index files are gitignored via patterns: `orama-*.json` and `local_cache/`"
    },
    {
      "subject": "Orama embeddings work seamlessly with fastembed - no format changes needed",
      "keywords": ["orama", "fastembed", "embeddings", "bge-small", "compatibility"],
      "applies_to": "file:src/core/embedding.ts",
      "content": "Orama vector search works directly with fastembed embeddings without any format conversion. The BGE-small-en-v1.5 model produces 384-dimensional vectors that work perfectly with Orama's `vector[384]` schema type. No changes needed to the embedding service or vector format."
    }
  ]
}
```
