---
id: 618bbfe7-da68-4d78-9c93-aa4f890c4efc
subject: >-
  Found it! The embedding service uses `fastembed` with `FlagEmbedding` which
  uses ONNX runtime under...
applies_to: global
occurred_at: '2025-12-03T11:19:54.362Z'
content_hash: 8f7e77ddb478364c
---
## Thought

Found it! The embedding service uses `fastembed` with `FlagEmbedding` which uses ONNX runtime under the hood - that's the source of the mutex errors. The file-based locking with `proper-lockfile` was supposed to help, but it's not working properly when 5 processes start concurrently.

The mutex error message "libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument" is from ONNX runtime, not sqlite-vec.

The issue is that:
1. 5 processes start at the same time
2. Each process tries to acquire the file lock
3. They might all read the lock file exists, then try to acquire it
4. But the ONNX runtime itself has its own internal mutexes that fail when multiple processes try to load it concurrently

The file locking should help, but it appears it's not working correctly. Let me check if maybe the lock file doesn't have write access or something is wrong with the locking mechanism.

Let me run the test again with some more visibility, or check if proper-lockfile is working correctly.

## Output

Found the issue. The mutex error is from **ONNX runtime** (used by fastembed), not sqlite-vec. The file-based locking with `proper-lockfile` isn't fully preventing concurrent ONNX model loading.

Let me test the locking mechanism:
