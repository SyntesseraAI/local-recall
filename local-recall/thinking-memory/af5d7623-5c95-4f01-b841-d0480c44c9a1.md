---
id: af5d7623-5c95-4f01-b841-d0480c44c9a1
subject: >-
  I think I found a key issue. Look at lines 171-180 and 183-193:```javascript//
  Run both episodic...
applies_to: global
occurred_at: '2025-12-03T10:03:46.970Z'
content_hash: d57306e87f8b5528
---
## Thought

I think I found a key issue. Look at lines 171-180 and 183-193:```javascript// Run both episodic and thinking vector syncs in parallel
Promise.all([
  runVectorSync().catch(...),
  runThinkingVectorSync().catch(...),
]);// Run both episodic and thinking extraction in parallel
Promise.all([
  runDaemonProcessing().catch(...),
  runThinkingDaemonProcessing().catch(...),
]);
```

So at startup:
1. After 2 seconds: Both `runVectorSync()` and `runThinkingVectorSync()` run **in parallel**
2. After 5 seconds: Both `runDaemonProcessing()` and `runThinkingDaemonProcessing()` run **in parallel**

And each of these functions:
- Creates a VectorStore/ThinkingVectorStore
- Calls `sync()` which opens database connections

Even though there are flags like `isSyncing` and `isThinkingSyncing`, they're separate flags! So both can be true at the same time, meaning both can be accessing the database concurrently.

Also, the HTTP server handlers (`handleEpisodicSearch` and `handleThinkingSearch`) can also be triggered at any time by hooks, potentially while the daemon is doing its sync operations.

The core problem is:
1. **Multiple concurrent database accesses** within the same process
2. Each access loads sqlite-vec
3. sqlite-vec's internal mutex handling doesn't work well with this pattern

The fix should be to **serialize all database operations** through a single queue or mutex, or use a **single shared database connection** for the entire daemon process lifecycle.Let me write up my findings.

## Output

Found the issue! There are multiple sources of concurrent database access in the daemon:

1. **Lines 171-180**: Vector syncs run in parallel: `runVectorSync()` and `runThinkingVectorSync()` simultaneously
2. **Lines 183-193**: Transcript processing runs in parallel
3. **HTTP handlers**: `handleEpisodicSearch` and `handleThinkingSearch` can be called anytime by hooks

Each of these creates separate database connections that load sqlite-vec. When they overlap (e.g., a hook triggers search while the daemon is syncing), the sqlite-vec internal mutex gets corrupted.

**The problem**: sqlite-vec doesn't handle well having multiple connections loaded in the same process doing concurrent operations.

The fix should serialize all database operations. Here's my suggested approach:
