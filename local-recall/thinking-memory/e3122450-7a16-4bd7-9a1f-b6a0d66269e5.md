---
id: e3122450-7a16-4bd7-9a1f-b6a0d66269e5
subject: >-
  Now I have the full picture. The issue is clear: ## Root Cause The `mutex lock
  failed: Invalid...
applies_to: global
occurred_at: '2025-12-03T09:30:27.815Z'
content_hash: 52dae432ecfe9b4d
---
## Thought

Now I have the full picture. The issue is clear:

## Root Cause

The `mutex lock failed: Invalid argument` error occurs because:

1. **Singleton pattern holds persistent database connections** - `getVectorStore()` and `getThinkingVectorStore()` create singleton instances with database connections that persist for the process lifetime

2. **sqlite-vec native extension uses internal mutexes** - When loading `sqlite-vec`, the native library creates mutexes for thread safety

3. **Process exit causes unpredictable destruction order** - When the hook calls `process.exit(0)`, Node.js garbage collects objects. The order of destruction is not guaranteed:
   - The `sqlite-vec` internal mutexes might be destroyed
   - Then some cleanup code tries to use those destroyed mutexes
   - This causes "mutex lock failed: Invalid argument"

4. **Multiple hook processes competing** - Both `user-prompt-submit.ts` and `user-prompt-submit-thinking.ts` run as separate processes, potentially at the same time, and both try to load `sqlite-vec` and access the database

## Solution

The fix is to make database connections ephemeral - open them for a single operation, then close them immediately. This is exactly what the user suggested: "connections only exist for atomic operations".

Here's my plan:

1. **Modify `VectorStore` class** to not use singleton pattern - each instance gets its own connection
2. **Add explicit connection lifecycle** - open at start of search, close at end
3. **Same changes for `ThinkingVectorStore`**
4. **Update `SearchEngine` and `ThinkingSearchEngine`** to create fresh stores per search
5. **Remove the singleton getters** or have them create new instances each time

Actually, looking at this more carefully, the cleanest approach is:
- Keep the VectorStore class but make it not hold the connection persistently
- Use a pattern where each search operation:
  1. Opens a connection
  2. Does the search
  3. Closes the connection in a finally block

I'll implement a robust connection management strategy that ensures clean, short-lived database interactions. The key is to create and destroy connections for each atomic operation, preventing any lingering resource conflicts or mutex-related errors.

## Output

Now I understand the issue. Based on the research and code review:

## Root Cause

The `mutex lock failed: Invalid argument` error happens because:

1. **Singleton pattern holds persistent database connections** - `getVectorStore()` and `getThinkingVectorStore()` create singletons with database connections that persist for the process lifetime
2. **sqlite-vec native extension uses internal mutexes** - when the process exits, Node.js garbage collects objects in an unpredictable order
3. **Mutex destroyed before cleanup completes** - the sqlite-vec internal mutexes may be destroyed while cleanup code is still trying to use them

From the [Stack Overflow research](https://stackoverflow.com/questions/30090108/what-does-mutex-lock-fail-with-invalid-argument-mean): *"This typically happens when .lock() is called on a mutex that is not yet constructed, or has already been destructed."*

And from the [Apache Arrow issue](https://github.com/apache/arrow/issues/15189): *"this might be something along the lines of a mutex lock attempt after the mutex has been destructed."*

## Solution

You're right - connections should only exist for atomic operations. Let me fix this:
