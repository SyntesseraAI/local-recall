---
id: 97120aed-a65c-4cd3-a922-99c1230b6405
subject: >-
  Looking at this transcript, I need to extract valuable memories about what was
  learned, discovered,...
applies_to: global
occurred_at: '2025-12-21T19:16:26.996Z'
content_hash: 2da07bf87b998a3e
---
## Thought

Looking at this transcript, I need to extract valuable memories about what was learned, discovered, and solved regarding the Local Recall codebase. The user was experiencing mutex errors when using sqlite-vec for vector search, and the assistant helped investigate and migrate to Orama.

Key learnings and discoveries:
1. The mutex error root cause - sqlite-vec uses C++ mutexes that fail with multi-process access
2. SQLite threading mode was THREADSAFE=2 (multi-thread) instead of THREADSAFE=1 (serialized)
3. The HTTP daemon architecture mentioned in CLAUDE.md wasn't actually implemented - daemon-client.ts and http-server.ts were deleted
4. Migration to Orama (pure JavaScript) as the solution
5. Technical discovery about Orama's default similarity threshold (0.8) filtering out legitimate results
6. Vector embeddings had ~0.77 similarity which was below the 0.8 threshold

Specific technical discoveries:
- The mutex error was "std::__1::system_error: mutex lock failed: Invalid argument"
- Orama persists to JSON, not a binary database
- Vector dimensions: 384 for embeddings
- The fix required setting `similarity: 0` in Orama search to disable Orama's built-in threshold filtering

This is valuable for future work on this codebase because:
1. The sqlite-vec approach doesn't work in a multi-process hook environment
2. Orama is the right choice (pure JS, no native dependencies)
3. The similarity threshold filtering caught many false negatives
4. Vector schema must include dimensions in Orama: `vector[384]`

Let me extract meaningful memories:

1. Memory about why sqlite-vec failed - the mutex issue
2. Memory about Orama's default similarity threshold behavior
3. Memory about the vector dimension specification (384)
4. Memory about the architecture decision (pure JS > native deps)
5. Memory about SQLite threading mode context


I'll organize these memories systematically, focusing on the technical insights and architectural decisions that emerged from the investigation.

## Output

```json
{
  "memories": [
    {
      "subject": "sqlite-vec mutex errors in multi-process hooks - root cause and fix",
      "keywords": ["sqlite-vec", "mutex", "threading", "hooks", "multi-process", "native C++", "error"],
      "applies_to": "global",
      "content": "# sqlite-vec Mutex Errors in Hooks\n\n## Root Cause\nThe mutex error `std::__1::system_error: mutex lock failed: Invalid argument` occurs because **sqlite-vec uses internal C++ pthread mutexes for vector operations**. These mutexes are process-local and fail when:\n- Multiple processes load sqlite-vec simultaneously (e.g., hook process + MCP server)\n- The process is exiting and mutex cleanup races occur\n- The process doesn't hold proper initialization state\n\n## Why File-Based Locking Didn't Help\nThe `withDbMutex` file-based locking only serialized SQLite database access, but couldn't prevent sqlite-vec's internal C++ mutex failures. The error happens at the native code level, not the SQLite database level.\n\n## Context: SQLite Threading Mode\nThe project's SQLite is in **multi-thread mode (THREADSAFE=2)**, not serialized mode (THREADSAFE=1). With THREADSAFE=2:\n- Each connection must be used by only one thread at a time\n- SQLite doesn't internally serialize operations\n- Application is responsible for synchronization\n\nThis mode is incompatible with hooks running in separate processes trying to query simultaneously.\n\n## Solution Implemented\nMigrated to **Orama** (pure JavaScript vector database) which has:\n- No native C++ dependencies\n- No mutex-related issues\n- JSON-based persistence (no file locking needed)\n- Compatible with multi-process hook architecture"
    },
    {
      "subject": "Orama default similarity threshold filtering caused false negatives",
      "keywords": ["orama", "similarity", "threshold", "vector search", "filtering", "relevance"],
      "applies_to": "global",
      "content": "# Orama Similarity Threshold Issue\n\n## Problem Discovered\nOrama has a built-in default similarity threshold of approximately **0.8**. Vector search results with similarity scores below 0.8 are silently filtered out and not returned.\n\n## Impact on Local Recall\nWhen searching for semantic matches using Ollama embeddings (384 dimensions), legitimate results with similarity ~0.77 were being discarded. This appeared as:\n- Vector search returning 0 results even with matching documents\n- Text search working but vector search failing\n- Persist/restore mechanism appearing broken (when it was actually working)\n\n## Root Cause\nOllama's nomic-embed-text model embeddings have a different similarity distribution than Orama's expected threshold. The ~0.77 similarity for semantically related content is valid but below Orama's default cutoff.\n\n## Solution\nSet `similarity: 0` in Orama search operations to disable Orama's built-in filtering. This allows us to:\n- Get all results with their actual similarity scores\n- Implement our own filtering logic based on configurable thresholds (episodicMinSimilarity, thinkingMinSimilarity)\n- Handle scoring the same way across episodic and thinking memories\n\n## Implementation\nModified vector search in both `src/core/vector-store.ts` and `src/core/thinking-vector-store.ts` to include `similarity: 0` in search options."
    },
    {
      "subject": "Vector schema specification in Orama requires dimension count",
      "keywords": ["orama", "vector", "schema", "dimensions", "embedding", "nomic-embed-text"],
      "applies_to": "global",
      "content": "# Orama Vector Schema Requirements\n\n## Vector Dimension Specification\nWhen creating Orama schemas with vector support, you must explicitly specify the vector dimension:\n```typescript\nvector: {\n  size: 384  // Must match your embedding model's dimension\n}\n```\n\n## For Local Recall\nUsing Ollama's `nomic-embed-text` model:\n- **Dimension**: 384 (not the 768 previously thought)\n- **Schema definition**: `vector[384]` in the schema\n- **Embedding function**: Uses Ollama API to generate embeddings\n\n## Persist/Restore Behavior\n- Orama persists to JSON format (not binary)\n- Schema with vector dimensions is preserved in persisted JSON\n- On restore, vector dimension must match the saved schema\n- Corrupted index files (with wrong schema) must be deleted and regenerated\n\n## Note\nDo NOT manually edit persisted JSON files as this can corrupt the vector index structure. Always delete and resync if index becomes corrupted."
    },
    {
      "subject": "HTTP daemon architecture from CLAUDE.md was not actually implemented",
      "keywords": ["architecture", "http daemon", "daemon-client", "hooks", "abstraction"],
      "applies_to": "global",
      "content": "# HTTP Daemon Architecture Gap\n\n## Documentation vs Reality\nThe CLAUDE.md documentation describes an \"HTTP daemon architecture\" where:\n- Hooks use HTTP client to query a background daemon\n- Daemon provides centralized vector search\n- Prevents multi-process issues\n\n## Reality\n`daemon-client.ts` and `http-server.ts` were deleted, and the implementation directly loads SearchEngine/ThinkingSearchEngine in hooks. This caused the sqlite-vec mutex issues.\n\n## Why It Matters\nThe documented architecture (HTTP daemon) would have been unnecessary with Orama because:\n- Orama is pure JavaScript with no native dependencies\n- JSON persistence works with file-based access\n- No mutex issues even with multi-process access\n\n## Current Implementation\nHooks directly instantiate vector stores and search engines. This works fine with Orama but should have failed with sqlite-vec if it were truly being used in multi-process mode as designed."
    },
    {
      "subject": "Migration from sqlite-vec to Orama - packages and dependencies",
      "keywords": ["migration", "orama", "sqlite-vec", "dependencies", "package.json", "build"],
      "applies_to": "global",
      "content": "# sqlite-vec to Orama Migration\n\n## Removed Dependencies\n- `better-sqlite3` - Native SQLite bindings\n- `sqlite-vec` - SQLite vector extension (C++)\n- `@types/better-sqlite3` - TypeScript definitions\n\n## Added Dependencies\n- `@orama/orama` - Pure JavaScript vector search\n- `@orama/plugin-data-persistence` - JSON-based index persistence\n\n## Files Removed\n- `src/utils/database.ts` - Mutex locking utilities (no longer needed)\n\n## Files Modified\n- `src/core/vector-store.ts` - Complete rewrite for Orama\n- `src/core/thinking-vector-store.ts` - Complete rewrite for Orama\n- `src/utils/gitignore.ts` - Updated to ignore Orama JSON index files\n- `src/mcp-server/server.ts` - Removed note about HTTP server\n- `src/hooks/user-prompt-submit.ts` - Removed comments about HTTP daemon\n- `package.json` - Updated dependencies\n\n## Build Impact\nBuild now completes successfully without native compilation step. No need for node-gyp or native toolchain."
    }
  ]
}
```
