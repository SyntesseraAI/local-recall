---
id: 1a44d9cf-688a-484c-b0fe-f11e904220b7
subject: >-
  The user is asking me to extract memories from the transcript. This is a
  [LOCAL_RECALL_INTERNAL]...
applies_to: global
occurred_at: '2025-12-21T19:33:20.813Z'
content_hash: e50b82fa7a939969
---
## Thought

The user is asking me to extract memories from the transcript. This is a [LOCAL_RECALL_INTERNAL] task for analyzing a Claude Code session transcript to extract valuable memories.

Let me analyze the transcript:

1. **What was learned?**
   - The "mutex lock failed: Invalid argument" error is caused by sqlite-vec's internal C++ mutexes being destroyed while threads try to lock them
   - The root cause is specifically related to pthread_mutex_lock() returning EINVAL when a mutex has already been destroyed
   - The error is macOS/platform-specific and related to how sqlite-vec manages thread safety
   - Current architecture had hooks and daemon completely independent with no IPC mechanism
   - Hooks were directly accessing sqlite-vec which caused the mutex issue

2. **What is now known?**
   - A hook-daemon communication architecture was implemented using HTTP
   - The HTTP server runs on port 7847 in the daemon
   - Hooks are now thin clients that make HTTP requests to the daemon instead of directly accessing sqlite-vec
   - This solves the mutex lock issue because only the daemon process accesses sqlite-vec
   - The daemon exposes endpoints:
     - POST /search/episodic
     - POST /search/thinking
     - POST /memories/recent
     - GET /health
   - Files created: src/mcp-server/http-server.ts, src/utils/daemon-client.ts
   - session-start hook was updated to use daemon client
   - user-prompt-submit hook was updated to use daemon client
   - MCP server was updated to start the HTTP server
   - All 289 tests pass

3. **What is specific to this codebase?**
   - The project uses sqlite-vec with better-sqlite3
   - The hooks were causing mutex contention by multiple processes accessing the same sqlite-vec database
   - Configuration is managed via types.ts with zod validation
   - Default HTTP port for daemon communication is 7847
   - The architecture previously had hooks doing direct vector search which caused concurrency issues
   
I resolved critical concurrency problems by implementing a centralized HTTP-based communication strategy. The new architecture isolates database access to a single daemon process, preventing mutex conflicts. By creating thin HTTP client hooks, I eliminated direct sqlite-vec access, which was causing thread safety issues on macOS. The solution introduces a clean separation of concerns, with port 7847 dedicated to daemon communication and standardized endpoints for vector search and memory management.

## Output

```json
{
  "memories": [
    {
      "subject": "Mutex lock failed error caused by sqlite-vec thread safety in hooks",
      "keywords": ["mutex", "sqlite-vec", "pthread_mutex_lock", "EINVAL", "thread safety", "native binding", "better-sqlite3"],
      "applies_to": "global",
      "content": "The 'mutex lock failed: Invalid argument' error (libc++abi std::__1::system_error) occurs when pthread_mutex_lock() returns EINVAL. This happens when a thread attempts to lock a mutex that has already been destroyed. In local-recall's context, this occurred because:\n\n1. Multiple hook processes (session-start, user-prompt-submit) were simultaneously accessing the same sqlite-vec database through better-sqlite3\n2. sqlite-vec uses internal C++ mutexes for thread safety\n3. When the first hook process completed and closed the database connection, it destroyed the mutex\n4. Subsequent hook processes trying to lock the destroyed mutex caused the error\n\nThe solution: Move all database/vector search operations to the MCP daemon which owns a single persistent database connection. Hooks become thin HTTP clients that request search results from the daemon instead of directly accessing sqlite-vec.\n\nThis is a critical architecture pattern for any project using better-sqlite3 with hooks or multiple processes."
    },
    {
      "subject": "Hook-daemon communication architecture via HTTP on port 7847",
      "keywords": ["http-server", "daemon client", "hook communication", "port 7847", "architecture", "ipc"],
      "applies_to": "global",
      "content": "Implemented hook-daemon communication using HTTP to solve the mutex contention issue:\n\n**New files:**\n- `src/mcp-server/http-server.ts` - HTTP server that runs in the daemon process\n- `src/utils/daemon-client.ts` - HTTP client library for hooks to use\n\n**HTTP endpoints (daemon on localhost:7847):**\n- POST /search/episodic - Vector search episodic memories\n- POST /search/thinking - Vector search thinking memories  \n- POST /memories/recent - Get recent memories by scope\n- GET /health - Health check\n\n**Hook changes:**\n- `src/hooks/user-prompt-submit.ts` - Updated to use DaemonClient instead of direct vector search\n- `src/hooks/session-start.ts` - Updated to use DaemonClient for recent memories endpoint\n\n**Key principle:** Only the daemon process opens and owns the sqlite-vec database connection. All database access goes through the daemon, eliminating concurrent access from multiple hook processes."
    },
    {
      "subject": "Configuration change: daemon HTTP port randomized to 7847",
      "keywords": ["port", "configuration", "7847", "http-server", "daemon", "config"],
      "applies_to": "file:src/core/types.ts",
      "content": "Changed the default HTTP port used by the daemon from the standard 3000 to a less-common port in the 7xxx range (specifically 7847) to reduce conflicts with other services that might use port 3000.\n\nConfiguration is defined in `src/core/types.ts` using zod schema validation. The port is configurable via environment variable if needed."
    },
    {
      "subject": "Session-start hook no longer uses sqlite-vec directly",
      "keywords": ["session-start", "hook", "memory retrieval", "daemon", "http-client"],
      "applies_to": "file:src/hooks/session-start.ts",
      "content": "The session-start hook was refactored to use the DaemonClient instead of direct MemoryManager access. It now makes HTTP requests to the daemon's `/memories/recent` endpoint to retrieve recent memories.\n\nOriginal implementation read markdown files directly via MemoryManager. New implementation:\n1. Creates DaemonClient instance\n2. Calls `client.getRecentMemories(scope, options)`\n3. Returns formatted memories to stdout\n\nThis ensures session-start doesn't directly access any vector search functionality, though it was previously safe since it only read markdown files."
    },
    {
      "subject": "All 289 tests pass after hook-daemon refactoring",
      "keywords": ["tests", "passing", "validation", "build", "npm test", "refactoring"],
      "applies_to": "global",
      "content": "After implementing the hook-daemon HTTP communication architecture:\n- TypeScript build completes successfully with npm run build\n- All 289 unit and integration tests pass\n- No regression or new failures introduced\n- The refactoring maintains backward compatibility for all functionality"
    }
  ]
}
```
