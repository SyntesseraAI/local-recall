---
id: 11e5888c-63f4-48d7-8bce-e1857d07b657
subject: >-
  The user is asking me to extract memories from a transcript where they worked
  on migrating...
applies_to: global
occurred_at: '2025-12-21T19:33:47.846Z'
content_hash: d86ac04ce1f510d7
---
## Thought

The user is asking me to extract memories from a transcript where they worked on migrating local-recall from sqlite-vec to Orama. Let me analyze what was learned, discovered, and solved:

1. **The Problem**: 
   - sqlite-vec was causing mutex errors when multiple processes tried to access it
   - The error was "mutex lock failed: Invalid argument" 
   - This was happening in hooks which were trying to open the database in read-only mode for queries
   - SQLite was running in multi-thread mode (THREADSAFE=2) instead of serialized mode

2. **Root Cause Analysis**:
   - sqlite-vec uses internal C++ std::mutex structures
   - These fail when multiple processes load the extension
   - The mutex error occurs at the native code level, not the SQLite database level
   - File-based locking doesn't help because the C++ mutexes are process-local

3. **Solution**: 
   - Migrated to Orama (pure JavaScript vector database)
   - Removed sqlite-vec and better-sqlite3 dependencies
   - Removed the database.ts utility that handled mutex locking
   - Created new Orama-based vector stores

4. **Key Technical Discoveries**:
   - Orama has a default similarity threshold of ~0.8 which was filtering out legitimate search results
   - The fix was to set `similarity: 0` to disable Orama's built-in threshold and handle filtering ourselves
   - Long content combined with Orama's default threshold was causing vector search failures
   - Persist/restore functionality works correctly in Orama

5. **Architecture Changes**:
   - Removed the http-server/daemon-client architecture that was supposed to be in place
   - Now hooks directly instantiate search engines using Orama (pure JS, no mutex issues)
   - No more process isolation issues since Orama is pure JavaScript

Let me extract these as memories:

1. **sqlite-vec mutex issue and solution**
   Encountered critical threading problems with sqlite-vec's C++ mutex implementation, requiring a complete migration to a pure JavaScript vector database to resolve process-level locking conflicts.

2. **SQLite threading mode configuration**
   Native SQLite extensions can create complex threading challenges, especially when running in multi-threaded mode. Proper configuration and understanding of thread safety modes are crucial for preventing mutex-related errors.

3. **Orama similarity threshold behavior**
   Vector search performance depends critically on similarity threshold settings. Orama's default 0.8 threshold was aggressively filtering results, necessitating manual threshold adjustment to 0 for comprehensive search coverage.

4. **Migration steps and dependencies removed**
   Streamlined the architecture by eliminating complex dependencies like sqlite-vec and better-sqlite3, replacing them with a lightweight, pure JavaScript vector database solution that simplifies process interactions.

5. **Why native C++ extensions cause process isolation issues**
   C++ extensions introduce low-level threading complexities that can break cross-process communication, making pure JavaScript solutions more reliable for maintaining consistent state and avoiding mutex-related failures.

## Output

```json
{
  "memories": [
    {
      "subject": "sqlite-vec causes mutex errors in multi-process hook execution",
      "keywords": [
        "sqlite-vec",
        "mutex",
        "process isolation",
        "hooks",
        "threading",
        "C++ extension"
      ],
      "applies_to": "global",
      "content": "## Problem\nsqlite-vec was causing 'mutex lock failed: Invalid argument' errors when hooks tried to access the database. This occurred despite opening in read-only mode and using file-based locking.\n\n## Root Cause\nsqlite-vec uses internal C++ `std::mutex` structures that are process-local. When multiple processes (hook processes and MCP server) load the extension, each creates their own mutex state. These C++ mutexes fail with 'Invalid argument' when:\n- The process is exiting and cleanup happens in wrong order\n- Multiple processes attempt simultaneous access\n- Mutex state becomes corrupted across process boundaries\n\nFile-based SQLite locking cannot prevent this because the error is at the C++ native code level, not the SQLite database level.\n\n## Solution\nMigrate to Orama (pure JavaScript vector database). Since Orama has no native dependencies, there are no process-local mutex issues. Hooks can directly instantiate Orama search engines without process isolation problems."
    },
    {
      "subject": "SQLite threading mode affects mutex behavior in better-sqlite3",
      "keywords": [
        "sqlite",
        "threading",
        "THREADSAFE",
        "multi-thread mode",
        "serialized mode",
        "mutex"
      ],
      "applies_to": "global",
      "content": "## SQLite Threading Modes\n\n| Mode | THREADSAFE Value | Behavior |\n|------|------------------|----------|\n| Single-thread | 0 | No mutexes, not thread-safe |\n| **Serialized** | 1 | Fully thread-safe, all operations serialized internally |\n| **Multi-thread** | 2 | Safe only if each database connection used by one thread at a time |\n\n## Current Configuration\nLocal Recall was using THREADSAFE=2 (multi-thread mode), which requires single-threaded access per connection. This doesn't work well with the hook architecture where multiple processes access the same database file.\n\n## Note\nWhile changing to THREADSAFE=1 could help with SQLite mutex issues, native extensions like sqlite-vec still have their own C++ mutex problems that file-based locking cannot fix."
    },
    {
      "subject": "Orama default similarity threshold filters valid results",
      "keywords": [
        "orama",
        "similarity",
        "threshold",
        "vector search",
        "filtering",
        "search results"
      ],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "## Problem\nOrama has a default similarity threshold of approximately 0.8. This causes semantically relevant results with similarity scores around 0.77 to be filtered out and not returned.\n\n## Solution\nWhen calling `search()`, explicitly set `similarity: 0` to disable Orama's built-in threshold filtering:\n\n```javascript\nconst results = await db.search({\n  term: query,\n  mode: 'hybrid',\n  limit: limit,\n  similarity: 0  // Disable Orama's threshold\n});\n```\n\nLocal Recall implements its own similarity filtering based on configured thresholds (default 0.5), so Orama's built-in threshold should be disabled to avoid double-filtering valid results.\n\n## Discovery\nThis issue was discovered when vector search returned 0 results despite embeddings being correctly stored. Long content combined with Orama's default threshold was causing legitimate matches to be filtered out."
    },
    {
      "subject": "Migration from sqlite-vec to Orama - dependencies and files removed",
      "keywords": [
        "orama",
        "migration",
        "dependencies",
        "sqlite-vec",
        "better-sqlite3",
        "pure javascript"
      ],
      "applies_to": "global",
      "content": "## Dependencies Removed\n- `better-sqlite3` - Native SQLite binding\n- `sqlite-vec` - C++ SQLite extension for vectors\n- `@types/better-sqlite3` - TypeScript types\n\n## Dependencies Added\n- `@orama/orama` - Pure JavaScript vector database\n- `@orama/plugin-data-persistence` - JSON persistence for Orama indexes\n\n## Files Removed\n- `src/utils/database.ts` - Contained mutex locking utilities (`withDbMutex`, `openDatabase`) that are no longer needed since Orama is pure JavaScript\n\n## Files Modified\n- `src/core/vector-store.ts` - Complete rewrite to use Orama API instead of better-sqlite3 + sqlite-vec\n- `src/core/thinking-vector-store.ts` - Same rewrite for thinking memories\n- `src/utils/gitignore.ts` - Updated to include `.gitignore` entries for `orama-episodic-index.json` and `orama-thinking-index.json` (these index files are gitignored)\n- `src/mcp-server/server.ts` - Updated comments (HTTP daemon removed, using direct Orama)\n- `src/hooks/user-prompt-submit.ts` - Removed HTTP daemon client comments\n- `package.json` - Dependencies updated\n\n## Key Insight\nThe HTTP server/daemon architecture mentioned in CLAUDE.md was removed before this session. The current architecture has hooks directly instantiate search engines, which works fine with Orama since it's pure JavaScript."
    },
    {
      "subject": "Native C++ extensions cause process isolation issues in hook architecture",
      "keywords": [
        "native extensions",
        "process isolation",
        "C++",
        "mutex",
        "hooks",
        "pure javascript"
      ],
      "applies_to": "global",
      "content": "## Why Native Extensions Are Problematic\nWhen Claude Code hooks load native C++ extensions like sqlite-vec:\n1. Each hook process gets its own copy of the C++ code in memory\n2. Each process creates its own native mutex state (pthread mutexes)\n3. These mutexes are tied to the process that created them\n4. Cleanup/destruction of mutexes when process exits can corrupt state\n5. File-based SQLite locking cannot protect against C++-level mutex failures\n\n## Why Pure JavaScript Works\nPure JavaScript libraries like Orama:\n- Don't have native process-local state\n- Use file-based coordination (JSON index files)\n- Have no mutex/threading primitives that fail across processes\n- Each process has its own in-memory cache but reads/writes same JSON files\n\n## Architectural Implication\nThe hook architecture (where multiple processes execute independently) is fundamentally incompatible with native C++ extensions that create process-local mutex state. Future extensions should be pure JavaScript or use proper inter-process communication (IPC)."
    }
  ]
}
```
