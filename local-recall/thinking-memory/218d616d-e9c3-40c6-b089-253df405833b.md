---
id: 218d616d-e9c3-40c6-b089-253df405833b
subject: >-
  The web search had partial results. Let me do more research by checking npm
  packages directly and...
applies_to: global
occurred_at: '2025-12-03T10:36:22.577Z'
content_hash: 7aea60a10c6920a9
---
## Thought

The web search had partial results. Let me do more research by checking npm packages directly and looking at specific alternatives. Let me think deeply about the best solutions for this problem.

The core issue is:
1. sqlite-vec has internal C++ mutexes that fail when loaded by multiple processes
2. better-sqlite3 compiles SQLite with THREADSAFE=2 (multi-thread, not serialized)
3. File-based locking doesn't prevent the sqlite-vec internal mutex issues

Let me think through the alternatives:

## Option 1: Different SQLite bindings

### sql.js (WebAssembly)
- Pure JavaScript/WebAssembly implementation
- No native code, no mutex issues
- But: Would need a vector extension that works with it (unlikely)
- Performance may be worse

### libsql
- SQLite fork from Turso
- Has native vector support (no extension needed)
- Better async support
- This could be a good option!

### Bun's SQLite
- Only works with Bun runtime
- User is using Node.js

## Option 2: Different vector stores

### Vectra
- Pure JavaScript
- Stores vectors in JSON files
- Uses HNSW algorithm
- No native dependencies!
- This could solve the mutex issue entirely

### LanceDB
- Embedded vector database
- Written in Rust with Node.js bindings
- Has its own storage format
- Good performance
- Could have similar native binding issues?

### VectorDB.js
- Simple in-memory vector database
- Uses local embeddings
- Very lightweight
- May not persist well

### hnswlib-node
- Node.js bindings for HNSW
- Fast nearest neighbor search
- Would need separate persistence

## Option 3: Architecture changes

### Use worker threads
- Run sqlite-vec operations in a dedicated worker thread
- Would isolate the mutex issues
- Complex to implement

### Restore HTTP daemon architecture
- Only daemon loads sqlite-vec


- Hooks communicate via HTTP
- This was the original design and it's proven to work

The core architectural challenge involves sqlite-vec's native extension behavior. When multiple Node.js processes interact with the same database, they create separate extension instances with independent mutex states. File-based locking provides file access serialization but cannot synchronize the internal mutex management across processes. This leads to potential memory corruption and synchronization errors when concurrent processes attempt to access shared database resources.

The mutex error signals deeper synchronization challenges, indicating potential memory management or state synchronization problems within the native extension's implementation. These issues emerge from the complex interaction between file-level locking and in-memory mutex management across multiple process contexts.

Potential solutions range from reverting to the original HTTP-based architecture to exploring alternative vector database technologies that offer more robust multi-process concurrency models. Each approach presents unique trade-offs between implementation complexity, performance, and long-term maintainability.

## Output

Let me research more deeply into specific alternatives:
