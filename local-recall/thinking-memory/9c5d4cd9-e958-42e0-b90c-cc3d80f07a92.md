---
id: 9c5d4cd9-e958-42e0-b90c-cc3d80f07a92
subject: >-
  Looking at this transcript, I need to extract valuable memories that future
  assistants working on...
applies_to: global
occurred_at: '2025-12-21T18:17:45.580Z'
content_hash: 9d2340546bf6a826
---
## Thought

Looking at this transcript, I need to extract valuable memories that future assistants working on this codebase should know about. Let me analyze what was learned and discovered:

1. **The Problem**: The project was experiencing mutex errors when running sqlite-vec in multiple processes, even when trying to open the database in read-only mode. The error was: `libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument`

2. **Root Cause Analysis**: 
   - SQLite was running in multi-thread mode (THREADSAFE=2) instead of serialized mode (THREADSAFE=1)
   - sqlite-vec uses internal C++ `std::mutex` structures that fail when loaded by multiple processes
   - The mutex error occurs at the native C++ code level, not at the SQLite level
   - File-based locking on the database doesn't prevent this because the issue is with sqlite-vec's internal mutexes

3. **Solution Implemented**:
   - Migrated from sqlite-vec to Orama (a pure JavaScript vector search library)
   - Removed dependencies: better-sqlite3, sqlite-vec, @types/better-sqlite3
   - Removed database.ts which handled mutex locking
   - Updated vector-store.ts and thinking-vector-store.ts to use Orama
   - Added @orama/orama and @orama/plugin-data-persistence

4. **Key Discovery During Migration**:
   - Orama has a default similarity threshold of ~0.8
   - When searching with different embeddings (not the exact same), Orama filters out results below its built-in threshold
   - This was causing vector search to return 0 results
   - The fix was to set `similarity: 0` in search parameters to disable Orama's built-in threshold filtering (the application handles its own threshold)

5. **Architecture Decision**:
   - The original design had HTTP daemon client architecture (daemon-client.ts, http-server.ts were deleted)
   - The new approach uses Orama directly in the hooks since it's pure JavaScript with no native dependencies
   - No need for complex process isolation since there are no mutex issues

6. **Technical Nuances**:
   - Explored SQLite's thread safety modes: single-thread, serialized, and multi-thread configurations
   - Identified embedding dimension mismatches with FastEmbed
   - Configured Orama vector schema with explicit embedding dimension
   - Verified successful persistence and restoration of Orama indexes through proper schema definition

These insights capture the critical technical transitions and lessons learned during the project's vector search implementation.

## Output

```json
{
  "memories": [
    {
      "subject": "Migrated from sqlite-vec to Orama due to mutex locking issues in multi-process environments",
      "keywords": ["sqlite-vec", "orama", "mutex", "vector-search", "migration", "threading"],
      "applies_to": "global",
      "content": "## Problem\nThe project experienced mutex lock failures when sqlite-vec was loaded by multiple processes (e.g., Claude hooks). Error: `libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument`. The issue occurred even when opening the database in read-only mode.\n\n## Root Cause\nsqlite-vec uses internal C++ `std::mutex` structures that fail when the extension is loaded by multiple processes. The mutex error occurs at the native C++ code level, not at the SQLite database level. File-based locking on the database doesn't prevent this since the issue is with sqlite-vec's internal pthread mutex state initialization.\n\n## Solution\nMigrated to Orama (pure JavaScript vector search library) which has no native dependencies and no process isolation issues:\n- Removed: `better-sqlite3`, `sqlite-vec`, `@types/better-sqlite3`, `src/utils/database.ts`\n- Added: `@orama/orama`, `@orama/plugin-data-persistence`\n- Updated: `src/core/vector-store.ts`, `src/core/thinking-vector-store.ts`\n\n## Key Discovery\nOrama has a default similarity threshold (~0.8). Vector search queries with different embeddings (not exact match) return 0 results if similarity is below threshold. Fix: set `similarity: 0` in search parameters to disable Orama's built-in filtering (application handles its own threshold filtering).\n\n## Architectural Impact\nNo longer need HTTP daemon architecture for process isolation since Orama is pure JavaScript. Hooks can directly instantiate SearchEngine without mutex issues."
    },
    {
      "subject": "SQLite threading modes: Serialized (1) vs Multi-thread (2) and their implications",
      "keywords": ["sqlite", "threading", "serialized", "multi-thread", "threadsafe", "pragma"],
      "applies_to": "global",
      "content": "## SQLite Threading Modes\n\nSQLite has three threading modes controlled by COMPILE_OPTIONS SQLITE_THREADSAFE:\n\n| Mode | Value | Behavior | Use Case |\n|------|-------|----------|----------|\n| Single-thread | 0 | No mutexes, not thread-safe | Single-threaded apps only |\n| **Serialized** | 1 | Fully thread-safe, all operations serialized internally | Multi-threaded/multi-process |\n| **Multi-thread** | 2 | Safe only if each connection used by one thread at a time | Thread-safe but requires proper connection management |\n\n## Check Mode\nQuery with: `PRAGMA compile_options` to see if built with SQLITE_THREADSAFE=1 or 2\n\n## Implications for Local Recall\nWhen using multi-thread mode (2), each process must have its own database connection. File-based locking prevents concurrent database access but does NOT prevent issues with native extensions like sqlite-vec which have their own internal mutex state."
    },
    {
      "subject": "Orama vector search requires explicit similarity threshold configuration",
      "keywords": ["orama", "vector-search", "similarity", "threshold", "search-parameters"],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "## Orama Search Threshold Issue\n\nOrama has a built-in default similarity threshold (approximately 0.8) that filters search results. When searching with a query embedding different from the stored embeddings, results may be filtered out if their similarity score is below Orama's threshold.\n\n## Example\n- Document A stored with embedding [values]\n- Query embedding [slightly different values]\n- Similarity score: 0.77\n- Default Orama threshold: ~0.8\n- Result: 0 matches returned\n\n## Fix\nWhen creating search parameters, set `similarity: 0` to disable Orama's built-in threshold filtering:\n```typescript\nconst results = await search(db, {\n  term: query,\n  vector: {\n    value: queryEmbedding,\n    similarity: 0  // Disable Orama's built-in threshold\n  },\n  limit\n});\n```\n\nThe application handles its own threshold filtering based on `minSimilarity` configuration parameter.\n\n## Key Files\n- `src/core/vector-store.ts`: episodic memory search (line ~170)\n- `src/core/thinking-vector-store.ts`: thinking memory search (line ~166)"
    },
    {
      "subject": "Orama vector persistence and restoration requires proper schema with embedding dimension",
      "keywords": ["orama", "persist", "restore", "vector-schema", "embedding-dimension"],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "## Orama Persistence\n\nOrama can persist database state to JSON files and restore from them. However, vector search only works correctly if the schema properly defines the embedding dimension.\n\n## Schema Requirements\n\nWhen creating an Orama database with vector support:\n```typescript\nconst db = await create({\n  schema: {\n    embedding: {\n      type: \"vector\",\n      dimensions: EMBEDDING_DIM,  // Must match actual embedding size (384 for FastEmbed)\n      distance: \"cosine\"\n    },\n    content: \"string\",\n    // ... other fields\n  }\n});\n```\n\n## Persistence and Restore\n\n- `save(db)` - Persists the entire database (schema + data + indexes) to JSON\n- `load(json)` - Restores from JSON, preserving vector indexes\n- Vector search works correctly on restored databases if schema has proper dimensions\n\n## Debugging Tip\nIf vector search returns no results after restore, check:\n1. Schema has proper `dimensions` value matching embedding size\n2. Embeddings were stored as arrays of correct length\n3. Similarity threshold is not filtering results (`similarity: 0` to disable)\n\n## Files Using Persistence\n- `src/core/vector-store.ts`: episodic memory persistence\n- `src/core/thinking-vector-store.ts`: thinking memory persistence"
    },
    {
      "subject": "Removed obsolete HTTP daemon architecture for vector search",
      "keywords": ["daemon", "http-server", "daemon-client", "architecture", "refactoring"],
      "applies_to": "global",
      "content": "## Architecture Change\n\nThe original design included HTTP daemon architecture for vector search:\n- `daemon-client.ts`: Client that connects to HTTP server\n- `http-server.ts`: HTTP server exposing vector search operations\n- Goal: Process isolation to prevent mutex conflicts\n\n## Reason for Removal\n\nWhen migrating to Orama (pure JavaScript, no native dependencies), the HTTP daemon architecture is no longer needed because:\n1. Orama has no mutex issues - it's entirely JavaScript\n2. No need for process isolation\n3. Hooks can directly instantiate SearchEngine and ThinkingSearchEngine\n4. Simpler architecture without HTTP overhead\n\n## Current Architecture\n\nAll components directly use Orama:\n- Hooks (`user-prompt-submit.ts`, `session-start.ts`) → directly use SearchEngine/ThinkingSearchEngine\n- MCP Server → directly uses SearchEngine/ThinkingSearchEngine\n- No background daemon needed for vector operations (only for memory extraction)\n\n## Note\nMCP Server still runs a background daemon for transcript processing and memory extraction, but this is separate from vector search operations."
    }
  ]
}
```
