---
id: 3ccd226b-9929-4d9e-9056-1136d6950e44
subject: >-
  Let me analyze this transcript to extract valuable memories for future
  sessions working on this...
applies_to: global
occurred_at: '2025-12-21T18:29:01.683Z'
content_hash: 2babcc7b0704aa4f
---
## Thought

Let me analyze this transcript to extract valuable memories for future sessions working on this codebase.

## What was learned:
1. The mutex lock error was caused by persistent singleton database connections with sqlite-vec
2. sqlite-vec uses internal mutexes that can be destroyed while cleanup code is still trying to use them
3. The solution is to use ephemeral connections - create a new database connection for each atomic operation and close it immediately
4. The refactoring involved changing from singleton pattern to factory pattern
5. There was a configuration issue where SearchEngine wasn't passing the correct baseDir to getVectorStore

## What is now known:
1. The vector-store.ts and thinking-vector-store.ts files used a singleton pattern that created persistent connections
2. The getVectorStore() and getThinkingVectorStore() factories were changed to create ephemeral instances
3. SearchEngine and ThinkingSearchEngine needed to be updated to pass the baseDir parameter
4. MemoryManager needed a getter for baseDir to support the refactoring
5. All 289 tests pass after the changes

## What is specific to this codebase:
1. This is a local-recall project using Orama for vector search
2. It uses sqlite-vec for embedding storage
3. Database connections need to be closed immediately after use to avoid mutex issues
4. The factory pattern is used with optional parameters for baseDir and readonly mode

## What problems were solved:
1. Root cause: Persistent singleton connections with sqlite-vec causing mutex errors on process exit
2. Solution: Convert to ephemeral connections - create connection, perform operation, close connection
3. Related fix: Ensure baseDir is passed correctly through the factory chain (SearchEngine -> getVectorStore)

Let me structure these as proper memories:

1. Memory about the mutex error root cause and solution
2. Memory about the connection management pattern change
3. Memory about the baseDir parameter issue
4. Memory about the testing and verification process

## Output

```json
{
  "memories": [
    {
      "subject": "sqlite-vec mutex error caused by persistent singleton connections",
      "keywords": ["mutex", "sqlite-vec", "singleton", "error", "connection", "lock failed"],
      "applies_to": "global",
      "content": "## Problem\nThe `UserPromptSubmit` hook was failing with: `libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument`\n\n## Root Cause\nThe codebase used a singleton pattern in `src/core/vector-store.ts` and `src/core/thinking-vector-store.ts` that created persistent database connections for the entire process lifetime. When the Node.js process exited, garbage collection destroyed objects in unpredictable order. sqlite-vec's internal mutexes could be destroyed while cleanup code was still trying to use them, causing the mutex lock error.\n\n## Solution\nRefactored to use **ephemeral connections**:\n- Changed `getVectorStore()` and `getThinkingVectorStore()` from singleton factories to ephemeral factories\n- Each operation (add, remove, search, sync, etc.) creates a fresh database connection\n- Connection is immediately closed after the atomic operation completes\n- Prevents sqlite-vec mutexes from being held across process lifetime\n\n## Impact\nAll 289 tests pass. The ephemeral connection pattern is cleaner and prevents resource leaks."
    },
    {
      "subject": "SearchEngine must pass baseDir to vector store factory",
      "keywords": ["searchengine", "basedir", "vector-store", "configuration", "factory"],
      "applies_to": "file:src/core/search.ts",
      "content": "## Issue\nAfter converting vector-store to use ephemeral connections, tests failed because `SearchEngine.search()` called `getVectorStore()` without passing the `baseDir` parameter.\n\nThe old singleton pattern masked this: the first call would set baseDir, and subsequent calls returned the same instance. With ephemeral instances, each call needs the correct baseDir.\n\n## Solution\n1. Added `getBaseDir()` getter to `MemoryManager` class\n2. Updated `SearchEngine` constructor to accept either `SearchEngineOptions` OR `MemoryManager`\n3. When instantiated with `MemoryManager`, extract its baseDir\n4. Pass baseDir to `getVectorStore({ baseDir, readonly })` calls\n\nThe same pattern was applied to `ThinkingSearchEngine`.\n\n## Code Pattern\n```typescript\nconst baseDir = this.memoryManager?.getBaseDir() || config.memoryDir;\nawait getVectorStore({ baseDir, readonly: this.readonly })\n```"
    },
    {
      "subject": "Ephemeral connection pattern for vector store operations",
      "keywords": ["ephemeral", "connections", "cleanup", "database", "lifecycle"],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "## Pattern\nThe vector-store now creates ephemeral database connections:\n\n```typescript\nexport async function getVectorStore(options?: VectorStoreOptions): Promise<VectorStore> {\n  return new VectorStore(options);\n}\n```\n\nEach operation in VectorStore creates a fresh connection and closes it:\n- `add()`: create connection, insert, close\n- `remove()`: create connection, delete, close\n- `search()`: create connection, query, close\n- `sync()`: create connection, bulk operations, close\n- `persist()`: create connection, export index, close\n\n## Benefits\n- Avoids mutex lock errors from long-lived connections\n- Prevents resource leaks\n- No process-level cleanup issues\n- Each operation is isolated and atomic"
    },
    {
      "subject": "WebSearch limitations for sqlite-vec debugging",
      "keywords": ["websearch", "sqlite-vec", "better-sqlite3", "research"],
      "applies_to": "global",
      "content": "When researching the `mutex lock failed` error with sqlite-vec and better-sqlite3, web searches returned no useful results for:\n- \"better-sqlite3 mutex lock failed Invalid argument threading error 2024\"\n- \"sqlite-vec better-sqlite3 'mutex lock failed' threading connection pool\"\n\nThe issue required examining the actual codebase to understand the singleton pattern and connection lifecycle rather than finding similar reported issues online. This type of architecture-specific problem often needs code analysis rather than web search."
    }
  ]
}
```
