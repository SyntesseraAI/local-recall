---
id: eea58fd0-bd45-4c40-b3e6-d085128f1291
subject: >-
  I see - the MemoryManager already uses `getVectorStore()` to add and remove
  memories. The issue is...
applies_to: global
occurred_at: '2025-12-03T09:33:47.319Z'
content_hash: 481960d8ae5bcb6e
---
## Thought

I see - the MemoryManager already uses `getVectorStore()` to add and remove memories. The issue is that each call to `getVectorStore()` now creates a NEW instance, so the data doesn't persist across different instances - each vector store instance creates its own connection to the database and closes it.

But wait - that should be fine since they all connect to the same SQLite database file. The database file persists the data. Let me think about this...

Oh! The issue is that the tests are expecting data to be found immediately after being added. With ephemeral connections:
1. Memory is created, added to vector store, connection closed2. Search is performed with a new vector store instance, new connection opened

That SHOULD work because the data is persisted in the SQLite file. But looking at the test failures:

1. "should make new memories searchable via vector search" - getting a different ID suggests there's existing data in the test dir or something else is going on
2. "expected false to be true" - this usually means the memory isn't being found

Looking at my changes, I removed the `this.db` persistent storage but the flow should be:1. `add()` opens connection, does insert, closes connection
2. `search()` opens connection, does query, closes connection

Both should hit the same SQLite file. Let me check if there's an issue with how the database path is being resolved...

Actually, wait - I think I see the issue! The `search.ts` file creates a `SearchEngine` which calls `getVectorStore({ readonly: this.readonly })`. But in the test, `searchEngine` is created with `new SearchEngine(memoryManager)` which is the legacy constructor.

Looking at search.ts:
```typescript
const vectorStore = getVectorStore({ readonly: this.readonly });
```

But `getVectorStore` is now:
```typescript
export function getVectorStore(options: VectorStoreOptions = {}): VectorStore {
  const baseDir = typeof options === 'string' ? options : options.baseDir;


```

The configuration resolution seems complex. The method handles different input types and falls back to default configurations. I suspect the test environment's directory settings might be interfering with how the vector store initializes its base directory. The interplay between environment variables, configuration options, and default settings could be causing unexpected behavior in memory persistence and retrieval.

## Output

Let me check how the config is being used - the issue might be that the SearchEngine and VectorStore are using different paths:
