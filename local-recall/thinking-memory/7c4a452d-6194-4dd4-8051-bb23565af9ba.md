---
id: 7c4a452d-6194-4dd4-8051-bb23565af9ba
subject: >-
  The user is asking me to extract memories from a transcript about the
  local-recall project. Let me...
applies_to: global
occurred_at: '2025-12-21T19:03:22.364Z'
content_hash: 47df49b57695caed
---
## Thought

The user is asking me to extract memories from a transcript about the local-recall project. Let me analyze what happened in this session:

1. **Root Cause Analysis**: The session started with investigating a "mutex lock failed: Invalid argument" error from the sqlite-vec extension in better-sqlite3. This is a C++ threading issue that occurs when a thread tries to lock a mutex that's been destroyed.

2. **Architecture Change**: The main work was implementing a hook-daemon communication architecture:
   - Previously: Hooks and daemon were completely independent, hooks tried to directly use sqlite-vec
   - Problem: sqlite-vec's internal C++ mutexes were being destroyed when hooks ran in separate processes
   - Solution: Expose HTTP API from the daemon for hooks to call instead
   - This prevents hooks from initializing sqlite-vec directly

3. **Key Implementation Details**:
   - Created `http-server.ts` with endpoints for searching memories
   - Created `daemon-client.ts` for hooks to call the HTTP API
   - Updated both `user-prompt-submit.ts` and `session-start.ts` hooks to use the daemon client
   - Port was changed to 7847 (random in 7xxx range)
   - All 289 tests passed after changes

4. **Specific to this codebase**:
   - sqlite-vec uses C++ mutexes internally
   - Hooks run as separate processes and can't share sqlite-vec state with daemon
   - The solution uses HTTP IPC between processes
   - session-start hook doesn't need sqlite-vec (only reads markdown files)

Let me extract valuable memories:

1. **The mutex error root cause and solution** - Important for anyone debugging similar issues
2. **Hook-daemon architecture pattern** - Important architectural decision for this project
3. **Port configuration** - Configuration quirk/preference discovered
4. **sqlite-vec threading considerations** - Technical constraint specific to this project
5. **HTTP endpoints for daemon** - Important for understanding the new architecture

Let me format these as memories:

## Output

```json
{
  "memories": [
    {
      "subject": "Mutex lock error caused by sqlite-vec in separate processes",
      "keywords": ["sqlite-vec", "mutex", "threading", "hooks", "daemon", "ipc", "error"],
      "applies_to": "global",
      "content": "# Mutex Lock Failed Error Analysis\n\n## Root Cause\n\nThe error `libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument` occurs when hooks attempt to initialize sqlite-vec in separate processes. sqlite-vec uses C++ mutexes internally that cannot be safely shared across process boundaries.\n\n## Why This Happens\n\n1. sqlite-vec has internal C++ mutexes for thread safety\n2. When a hook process initializes the vector store, it creates new mutexes\n3. If the daemon also initializes sqlite-vec, mutex destruction order becomes unpredictable\n4. A thread attempting to lock a destroyed mutex returns EINVAL (Invalid argument)\n\n## Solution\n\nEliminate direct sqlite-vec usage in hooks by:\n1. Running vector store operations only in the daemon process\n2. Exposing HTTP API from daemon for hooks to call\n3. Hooks become thin clients that don't initialize sqlite-vec\n\nThis keeps all sqlite-vec state in a single process (the daemon)."
    },
    {
      "subject": "Implemented hook-daemon HTTP communication architecture",
      "keywords": ["hooks", "daemon", "http", "ipc", "architecture", "refactor"],
      "applies_to": "global",
      "content": "# Hook-Daemon Communication Architecture\n\n## Previous Design (Broken)\n\nHooks and daemon were completely independent:\n- Each process initialized its own sqlite-vec vector store\n- Caused mutex conflicts across processes\n- Redundant vector store initialization\n\n## New Design\n\n**Daemon** runs HTTP server with search endpoints:\n- `POST /search/episodic` - Vector search for episodic memories\n- `POST /search/thinking` - Vector search for thinking memories  \n- `POST /memories/recent` - Get recent memories\n- `GET /health` - Health check\n- Default port: `7847` (randomly chosen in 7xxx range)\n\n**Hooks** use `daemon-client.ts` to call daemon via HTTP:\n- `user-prompt-submit.ts` - Calls `/search/episodic` and `/search/thinking`\n- `session-start.ts` - Calls `/memories/recent` (doesn't need vector store)\n\n## Benefits\n\n1. Single sqlite-vec instance (no mutex conflicts)\n2. Hooks remain lightweight (no native dependencies)\n3. Clean separation of concerns\n4. Easier to test and debug"
    },
    {
      "subject": "HTTP port configuration randomized to 7847",
      "keywords": ["config", "port", "daemon", "http", "7847"],
      "applies_to": "file:src/core/types.ts",
      "content": "# Daemon HTTP Port Configuration\n\nThe daemon HTTP server default port is set to `7847` - a randomly chosen port in the 7xxx range. This helps avoid conflicts with common service ports while remaining in an unprivileged range.\n\nConfigurable via:\n- `config.ts` default: `7847`\n- Environment variable: `LOCAL_RECALL_HTTP_PORT`\n\nHooks discover the port from configuration and connect via `http://localhost:7847`."
    },
    {
      "subject": "session-start hook doesn't use sqlite-vec (safe from mutex issue)",
      "keywords": ["session-start", "hook", "sqlite-vec", "safe"],
      "applies_to": "file:src/hooks/session-start.ts",
      "content": "# Session Start Hook Thread Safety\n\n## No Direct Database Access\n\nThe `session-start.ts` hook only reads markdown files via `MemoryManager` and doesn't initialize sqlite-vec or the vector store. It simply:\n1. Calls daemon's `/memories/recent` endpoint\n2. Outputs recent memories to stdout for context injection\n\nBecause it doesn't load sqlite-vec, it's safe from mutex contention issues. All vector database operations are delegated to the daemon.\n\n## Implication\n\nThis hook can remain lightweight and has no native dependencies."
    },
    {
      "subject": "All 289 tests pass with new hook-daemon architecture",
      "keywords": ["testing", "refactor", "regression", "validation"],
      "applies_to": "global",
      "content": "# Test Coverage After Refactor\n\nAfter implementing the hook-daemon HTTP communication architecture:\n- All 289 existing tests continue to pass\n- No test failures introduced by the refactor\n- HTTP communication between hooks and daemon is working correctly\n\nThis validates that the architectural change is backward compatible with existing functionality."
    }
  ]
}
```
