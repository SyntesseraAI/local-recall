---
id: e50a7d18-248f-4d29-bd2a-6ad4bfc11adc
subject: >-
  Good, gitignore is updated. Now let me research and present options for
  mutex/semaphore on...
applies_to: global
occurred_at: '2025-12-03T11:14:22.409Z'
content_hash: a1a1a1f7d36e8690
---
## Thought

Good, gitignore is updated. Now let me research and present options for mutex/semaphore on fastembed.

## Output

Done. Now for mutex/semaphore options for fastembed:

## Options for Serializing fastembed/onnxruntime Access

### 1. **File-based lock (proper-lockfile / lockfile)**
```typescript
import lockfile from 'proper-lockfile';

async function withEmbeddingLock<T>(fn: () => Promise<T>): Promise<T> {
  const lockPath = '/tmp/local-recall-embedding.lock';
  const release = await lockfile.lock(lockPath, { retries: 10 });
  try {
    return await fn();
  } finally {
    await release();
  }
}
```
**Pros**: Cross-process, simple, battle-tested  
**Cons**: Filesystem-based, slight overhead

### 2. **Unix socket / named pipe semaphore**
Create a semaphore server that hooks connect to for embedding access.
**Pros**: Fast, proper IPC  
**Cons**: More complex, need to manage server lifecycle

### 3. **Singleton daemon with lazy init**
Only one process (MCP daemon) initializes fastembed; hooks wait if it's busy.
**Pros**: Keeps current HTTP architecture pattern  
**Cons**: Requires daemon to be running

### 4. **Process-level mutex via `async-mutex` + lockfile**
```typescript
import { Mutex } from 'async-mutex';
import lockfile from 'proper-lockfile';

const localMutex = new Mutex();

async function safeEmbed(text: string): Promise<number[]> {
  // Local mutex for same-process concurrency
  return localMutex.runExclusive(async () => {
    // File lock for cross-process concurrency
    const release = await lockfile.lock('/tmp/embedding.lock');
    try {
      return await embeddingService.embed(text);
    } finally {
      await release();
    }
  });
}
```
**Pros**: Handles both in-process and cross-process  
**Cons**: Serializes all embeddings (slower)

### 5. **Retry with exponential backoff**
Catch mutex errors and retry after delay.
**Pros**: Simple, non-blocking approach  
**Cons**: Still gets errors, just handles them gracefully

---

**Recommendation**: Option 1 or 4 - file-based lock is the simplest and most reliable for cross-process serialization. The `proper-lockfile` package handles edge cases like stale locks and retries.
