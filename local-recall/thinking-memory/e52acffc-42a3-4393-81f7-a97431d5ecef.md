---
id: e52acffc-42a3-4393-81f7-a97431d5ecef
subject: >-
  Looking at this transcript, I need to extract valuable memories from this
  Claude Code session. The...
applies_to: global
occurred_at: '2025-12-21T19:00:18.304Z'
content_hash: b49366aceb4643d5
---
## Thought

Looking at this transcript, I need to extract valuable memories from this Claude Code session. The session is about investigating and fixing a "mutex lock failed: Invalid argument" error in the local-recall project, and implementing a hook-daemon communication architecture using HTTP.

Let me identify the key learnings and insights:

1. **Root Cause Discovery**: The mutex error happens when a thread attempts to lock a mutex that has already been destroyed. This is specifically related to sqlite-vec's internal C++ mutexes.

2. **Architecture Change**: The session involved implementing a hook-daemon communication system using HTTP to avoid direct sqlite-vec access from hooks (which causes the mutex issue). This is a significant architectural decision.

3. **Specific Implementation Details**:
   - Created http-server.ts in mcp-server
   - Created daemon-client.ts utility
   - Updated hooks (user-prompt-submit.ts, session-start.ts) to use daemon client
   - Session-start doesn't use sqlite-vec (safe from mutex issue)
   - Default HTTP port changed to 7847

4. **Technical Details**:
   - Better-sqlite3 with sqlite-vec has threading issues
   - The hooks should be thin clients that communicate with the daemon
   - The daemon owns the database connections
   - Tests all passed (289 tests)

5. **Configuration**: HTTP port is now 7847 instead of 3000

Let me extract the most valuable memories:

1. The mutex error cause and why it happens
2. The architectural decision to use HTTP for hook-daemon communication
3. Which components use sqlite-vec and which don't
4. The port number for HTTP communication
5. The new HTTP endpoints available

Let me structure these as memories:

Memory 1: Mutex Lock Failed Error Root Cause
- Subject: Mutex lock failed error occurs when threads lock destroyed mutexes
- Keywords: mutex, sqlite-vec, threading, error, invalid-argument
- Applies_to: global
- Content: Details about the error and root cause


- Insights: The error stems from complex threading interactions in sqlite-vec's C++ implementation

I'll focus on the next memory about the hook-daemon architecture. The core insight is creating a communication layer that isolates hooks from direct database access. This approach prevents threading complications by centralizing database interactions in a single daemon process. The HTTP-based communication ensures clean separation of concerns, with hooks acting as lightweight clients requesting data or performing actions through well-defined endpoints.

The session-start hook represents a specific example of this safety approach. By avoiding direct sqlite-vec interactions and instead reading markdown files through a memory management system, it sidesteps potential mutex-related threading issues entirely.

The architectural shift introduces a more robust, scalable approach to managing database interactions across the application, with clear boundaries between components and reduced risk of concurrent access problems.

## Output

```json
{
  "memories": [
    {
      "subject": "Mutex lock failed error caused by destroyed mutex in sqlite-vec",
      "keywords": [
        "mutex",
        "sqlite-vec",
        "threading",
        "error",
        "invalid-argument",
        "pthread"
      ],
      "applies_to": "global",
      "content": "The 'mutex lock failed: Invalid argument' error (EINVAL from pthread_mutex_lock) occurs when a thread attempts to lock a mutex that has already been destroyed. In sqlite-vec context, this happens because better-sqlite3 uses internal C++ mutexes for thread safety, and multiple concurrent processes accessing the same SQLite database can cause mutex destruction issues. This is a fundamental limitation of direct sqlite-vec access from multiple hooks running in parallel."
    },
    {
      "subject": "Hook-daemon HTTP architecture solves sqlite-vec threading issues",
      "keywords": [
        "architecture",
        "hooks",
        "daemon",
        "http",
        "ipc",
        "threading",
        "sqlite-vec"
      ],
      "applies_to": "global",
      "content": "Implemented HTTP-based communication between hooks and daemon to avoid direct sqlite-vec access from multiple hook processes. Hooks become thin clients that POST requests to the daemon, which owns and manages the SQLite database connection. This ensures only one process accesses sqlite-vec, eliminating mutex contention. New files: http-server.ts (daemon), daemon-client.ts (hook utility). HTTP endpoints: POST /search/episodic, POST /search/thinking, POST /memories/recent, GET /health."
    },
    {
      "subject": "Session-start hook doesn't use sqlite-vec, safe from mutex issues",
      "keywords": [
        "session-start",
        "hook",
        "safe",
        "sqlite-vec",
        "markdown"
      ],
      "applies_to": "file:src/hooks/session-start.ts",
      "content": "The session-start hook only reads markdown files directly via MemoryManager and doesn't load the vector store, so it's not affected by sqlite-vec mutex issues. It can continue to operate independently without needing the daemon. However, it was updated to optionally use the daemon client for consistency if needed in the future."
    },
    {
      "subject": "Default HTTP daemon port is 7847",
      "keywords": [
        "port",
        "http",
        "configuration",
        "daemon",
        "7847"
      ],
      "applies_to": "global",
      "content": "The daemon's HTTP server listens on port 7847 (changed from 3000 for less collision). This is the port that hooks connect to when making requests. Configurable via config system if needed."
    },
    {
      "subject": "Daemon HTTP API endpoints for memory operations",
      "keywords": [
        "http-server",
        "endpoints",
        "api",
        "daemon",
        "search"
      ],
      "applies_to": "file:src/mcp-server/http-server.ts",
      "content": "Daemon exposes HTTP API with endpoints: POST /search/episodic (vector search episodic memories), POST /search/thinking (vector search thinking memories), POST /memories/recent (get recent memories), GET /health (health check). All search endpoints accept query parameter and options (maxTokens, minSimilarity, limit). Response includes memories array with similarity scores."
    }
  ]
}
```
