---
id: a439afa0-c423-47aa-84eb-2c58cd007f74
subject: >-
  Looking at this transcript, I need to extract the key memories from this
  debugging session where...
applies_to: global
occurred_at: '2025-12-21T19:21:16.443Z'
content_hash: 269a4c93779f0f9c
---
## Thought

Looking at this transcript, I need to extract the key memories from this debugging session where the user was fixing a mutex lock error in sqlite-vec. Let me analyze what was learned and discovered:

1. **Root Cause of mutex error**: The issue was caused by persistent singleton database connections combined with sqlite-vec's internal mutexes. When the process exits, Node.js garbage collects objects unpredictably, causing mutexes to be destroyed while still in use.

2. **Solution implemented**: Changed from singleton pattern with persistent connections to ephemeral connections that only exist for atomic operations.

3. **Code changes made**:
   - `src/core/vector-store.ts`: Refactored to use ephemeral connections
   - `src/core/thinking-vector-store.ts`: Similar refactoring
   - `src/core/search.ts`: Updated to pass baseDir correctly
   - `src/core/memory.ts`: Added baseDir getter
   - `src/core/thinking-search.ts`: Updated similarly

4. **Test issues discovered and fixed**: 
   - Tests were failing because SearchEngine wasn't passing the correct baseDir
   - The old singleton pattern masked this issue - now with ephemeral instances, each call needs the correct baseDir

5. **Architecture insight**: The search engines and vector stores need to know the baseDir to operate correctly, which was previously masked by the singleton pattern.

Let me extract the valuable memories:

1. **Mutex error root cause and solution** - sqlite-vec threading/connection issue
2. **Singleton pattern masked baseDir issues** - ephemeral connections exposed configuration problems
3. **VectorStore/SearchEngine relationship** - they need matching baseDirs
4. **SQLite-vec native extension threading** - mutexes destroyed unexpectedly during process exit
5. **Ephemeral connection pattern** - connections should only exist for atomic operations

These are specific to this codebase and would help future assistants understand:
- Why the connections were changed from singletons to ephemeral


The threading complexity stems from how Node.js manages native extensions and database connections. I'm tracking the intricate interactions between the search engine and vector store, which require precise baseDir configuration to prevent mutex conflicts.

The core challenge involves synchronizing the lifecycle of database connections across different components. Each search operation needs a clean, isolated connection context to prevent race conditions and unexpected mutex destruction. By enforcing explicit baseDir passing, we ensure that every database interaction has the correct initialization parameters, preventing silent failures that were previously hidden by the singleton approach.

This means carefully threading the baseDir through initialization methods, ensuring that vector stores and search engines have consistent, atomic connection management. The ephemeral connection strategy forces explicit configuration, making potential configuration errors immediately visible during development.

## Output

```json
{
  "memories": [
    {
      "subject": "Mutex lock failed error caused by singleton database connections with sqlite-vec native mutexes",
      "keywords": [
        "sqlite-vec",
        "mutex",
        "singleton",
        "threading",
        "database connection",
        "garbage collection"
      ],
      "applies_to": "global",
      "content": "The `libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument` error was caused by a combination of two factors:\n\n1. **Persistent Singleton Pattern**: The old code used singleton instances (`getVectorStore()`, `getThinkingVectorStore()`) that held database connections for the entire process lifetime.\n\n2. **SQLite-vec Mutex Issue**: The sqlite-vec native extension uses internal C++ mutexes for thread safety. When Node.js process exits, it garbage collects objects in unpredictable order. If a mutex is destroyed while cleanup code is still trying to acquire it, you get the \"mutex lock failed\" error.\n\n**Solution**: Refactored to use **ephemeral connections** - each database operation (add, remove, search) creates a fresh connection, performs the atomic operation, then closes it. This ensures connections never persist beyond their needed scope."
    },
    {
      "subject": "Vector store connections should be ephemeral, only existing for atomic operations",
      "keywords": [
        "connection pooling",
        "ephemeral",
        "atomic operations",
        "database lifecycle",
        "vector-store"
      ],
      "applies_to": "file:src/core/vector-store.ts",
      "content": "The refactored architecture creates database connections on-demand within each method and closes them immediately after the operation completes:\n\n- `add()`, `remove()`, `search()`, `sync()`, `persist()` methods each manage their own connection lifecycle\n- No singleton instance maintains persistent connections\n- Each method gets a fresh database handle and closes it before returning\n\nThis pattern prevents mutex contention and ensures clean resource cleanup without relying on garbage collection timing."
    },
    {
      "subject": "Singleton pattern masked baseDir configuration issues in search engines",
      "keywords": [
        "singleton",
        "baseDir",
        "configuration",
        "memory manager",
        "search engine"
      ],
      "applies_to": "global",
      "content": "When using the singleton pattern, the first call to `getVectorStore()` would set the baseDir globally, and subsequent calls returned the same instance. This masked a critical issue:\n\n**Problem**: `SearchEngine.search()` calls `getVectorStore({ readonly: this.readonly })` without passing the `baseDir`, causing it to use the global config's `memoryDir` instead of matching the `MemoryManager`'s baseDir.\n\n**Impact**: With ephemeral connections, each call now needs the correct baseDir passed explicitly.\n\n**Fix**: Added a `getBaseDir()` getter to `MemoryManager` so that `SearchEngine` (when constructed with a `MemoryManager`) can retrieve and pass the correct baseDir to the vector store. Similar fix applied to `ThinkingSearchEngine` with `ThinkingMemoryManager`."
    },
    {
      "subject": "SearchEngine and VectorStore must operate on the same baseDir",
      "keywords": [
        "memory manager",
        "search engine",
        "vector store",
        "initialization",
        "configuration passing"
      ],
      "applies_to": "file:src/core/search.ts",
      "content": "The `SearchEngine` constructor accepts either `SearchEngineOptions` with explicit `baseDir` and `vectorStore`, or a `MemoryManager` legacy constructor. When using the legacy constructor:\n\n1. The `SearchEngine` needs access to the `MemoryManager`'s baseDir\n2. This baseDir must be passed to any `getVectorStore()` calls\n3. Otherwise the vector store will use the global config path, creating a mismatch\n\n**Implementation**: Added `getBaseDir()` getter to `MemoryManager` and updated `SearchEngine` constructor to extract and store this baseDir, then pass it when initializing the vector store."
    },
    {
      "subject": "Test failures revealed configuration path issues in vector store initialization",
      "keywords": [
        "integration tests",
        "memory lifecycle",
        "test fixtures",
        "vector store initialization",
        "baseDir mismatch"
      ],
      "applies_to": "file:tests/integration/memory-lifecycle.test.ts",
      "content": "Integration tests expected `MemoryManager.createMemory()` to automatically add memories to the vector store, but tests were failing because the SearchEngine wasn't being initialized with the same baseDir as the MemoryManager. The tests use a custom memory directory that differs from the global config default, making the baseDir mismatch visible. Once the SearchEngine properly received the baseDir from MemoryManager, all 289 tests passed."
    }
  ]
}
```
