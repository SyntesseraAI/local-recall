---
id: 46be6a2b-c47c-4582-b29c-1921ee8efb38
subject: >-
  Let me analyze the transcript to extract valuable memories about the
  local-recall codebase. Key...
applies_to: global
occurred_at: '2025-12-03T09:57:50.216Z'
content_hash: 0c53e813e86df556
---
## Thought

Let me analyze the transcript to extract valuable memories about the local-recall codebase.

Key learnings from this session:

1. **Mutex Lock Failed Issue**: There's a known issue with sqlite-vec on macOS where "mutex lock failed: Invalid argument" occurs. This is a threading issue in native code when a thread attempts to lock a mutex that has been destroyed. The root cause is sqlite-vec using internal C++ mutexes for thread safety.

2. **Architecture Redesign**: The session involved moving from a direct database access model (both hooks and daemon accessing sqlite-vec) to a client-server architecture where:
   - The MCP daemon maintains the sqlite-vec database connection
   - Hooks communicate with the daemon via HTTP API instead of direct database access
   - This solves the mutex issue by centralizing database access

3. **Components Created/Modified**:
   - `src/mcp-server/http-server.ts`: New HTTP server for daemon to expose API
   - `src/utils/daemon-client.ts`: New client for hooks to communicate with daemon
   - `src/hooks/user-prompt-submit.ts`: Updated to use daemon client instead of direct database access
   - `src/hooks/session-start.ts`: Updated to use daemon client
   - `src/mcp-server/server.ts`: Updated to start HTTP server

4. **Hook Architecture**: 
   - `session-start.ts` reads markdown files directly (safe, no database access needed)
   - `user-prompt-submit.ts` does semantic search via daemon HTTP API
   - Hooks are now thin clients that don't directly access sqlite-vec

5. **Database Connection Pattern**: The vector-store uses better-sqlite3 with sqlite-vec extension. Direct multi-process access to the same SQLite database causes mutex issues. The solution is centralizing database access in the daemon.

Let me extract these as specific memories:

Memory 1: Mutex lock failure with sqlite-vec
- Subject: "sqlite-vec mutex lock failure: Invalid argument on macOS with concurrent access"


- Keywords: ["mutex", "sqlite-vec", "threading", "invalid argument", "macOS", "concurrent access"]
- applies_to: "global"
- Content: The mutex lock failure stems from threading complexities in native code, specifically when multiple processes attempt to access the SQLite database simultaneously. On macOS, this manifests as an "Invalid argument" error when threads try to interact with destroyed mutex locks.

Memory 2: Architecture redesign - daemon HTTP API
- Subject: "Daemon exposes HTTP API for hooks to avoid sqlite-vec concurrent access issues"
- Keywords: ["architecture", "http-api", "daemon", "hooks", "client-server", "concurrent access"]
- applies_to: "global"
- Content: I've implemented a client-server model where the daemon becomes the single point of database access. Hooks now communicate through an HTTP API, eliminating direct database interactions and resolving concurrent access problems.

Memory 3: Hook communication pattern
- Subject: "Hooks communicate with daemon via HTTP client to avoid direct sqlite-vec access"
- Keywords: ["hooks", "http-client", "daemon", "decoupled", "safe access"]
- Content: Hooks are now lightweight clients that request data through a standardized HTTP interface. This approach isolates database operations, prevents race conditions, and provides a clean separation of concerns in the system architecture.

Memory 4: Session start hook doesn't need database
- Subject: "session-start hook reads markdown files directly, no database access needed"
- Keywords: ["lightweight", "file-based", "initialization", "minimal dependency"]
- Content: The session-start hook operates independently, reading markdown configuration files directly. By avoiding database queries during initialization, it remains fast and reduces potential synchronization overhead.

Memory 5: User prompt submit hook uses HTTP
- Subject: "user-prompt-submit hook searches memories via daemon HTTP API"
- Keywords: ["search", "delegated", "stateless", "efficient"]
- Content: When a user submits a prompt, the hook delegates memory searching to the daemon through a lightweight HTTP request. This approach centralizes complex search logic and ensures thread-safe, consistent memory retrieval.

## Output

```json
{
  "memories": [
    {
      "subject": "sqlite-vec mutex lock failure: Invalid argument occurs with concurrent database access",
      "keywords": ["sqlite-vec", "mutex", "threading", "invalid argument", "concurrent access", "macOS", "native code", "pthread"],
      "applies_to": "global",
      "content": "## Problem\n\nWhen multiple processes access the same SQLite database with sqlite-vec (better-sqlite3 + sqlite-vec extension), a threading error occurs:\n\n```\nlibc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument\n```\n\n## Root Cause\n\nsqlite-vec uses internal C++ mutexes (`pthread_mutex_t`) for thread safety. When multiple processes attempt to lock a mutex that has been destroyed by another process, `pthread_mutex_lock()` returns `EINVAL` (Invalid argument).\n\n## Solution\n\nCentralize database access in a single daemon process. All other processes (hooks) communicate with the daemon via IPC (HTTP API) instead of accessing the database directly.\n\n## Implementation\n\nThe daemon:\n- Holds the only sqlite-vec database connection\n- Exposes HTTP API endpoints for search and other operations\n- Runs as a persistent background process\n\nHooks:\n- No longer access sqlite-vec directly\n- Use DaemonClient to call HTTP endpoints\n- Much simpler, more reliable"
    },
    {
      "subject": "New architecture: daemon HTTP server with hook clients to avoid sqlite-vec mutex issues",
      "keywords": ["architecture", "http-server", "daemon-client", "client-server", "design pattern", "refactor"],
      "applies_to": "global",
      "content": "## Architecture Overview\n\n```\n┌──────────────────────┐\n│   MCP Daemon         │\n│ • HTTP Server (port) │\n│ • sqlite-vec DB      │\n│ • Vector Store       │\n│ • Search Logic       │\n└──────────────────────┘\n       ↑        ↑\n    HTTP      HTTP\n       ↓        ↓\n┌──────────────────────┐  ┌──────────────────────┐\n│  Hook Process 1      │  │  Hook Process 2      │\n│ (session-start)      │  │ (user-prompt-submit) │\n│ • DaemonClient       │  │ • DaemonClient       │\n│ • HTTP calls only    │  │ • HTTP calls only    │\n└──────────────────────┘  └──────────────────────┘\n```\n\n## New Components\n\n- `src/mcp-server/http-server.ts`: Daemon's HTTP server exposing API\n- `src/utils/daemon-client.ts`: Client for hooks to call daemon\n- Updated hooks to use DaemonClient instead of direct database access\n\n## Benefits\n\n1. Single database connection = no mutex contention\n2. Hooks are thin clients = simpler code, less prone to issues\n3. Daemon can be reused by multiple tools (MCP, CLI, etc)\n4. IPC via HTTP = easy to debug, language-agnostic"
    },
    {
      "subject": "session-start hook reads markdown files directly, does not need database access",
      "keywords": ["session-start", "hook", "MemoryManager", "markdown", "architecture", "optimization"],
      "applies_to": "file:src/hooks/session-start.ts",
      "content": "## Implementation Detail\n\nThe session-start hook loads recent memories WITHOUT database/sqlite-vec access:\n\n1. Calls `MemoryManager.listMemories()` which reads markdown files from disk\n2. Sorts by `occurred_at` timestamp\n3. Returns top 5 most recent memories\n4. Outputs to stdout for Claude injection\n\n## Why This Works\n\nSession-start doesn't need semantic search - it just needs the most recent memories. Reading markdown files is fast and doesn't require vector embeddings or database access.\n\n## Note\n\nDespite reading markdown files directly, session-start was updated to use DaemonClient for consistency. However, the daemon's HTTP endpoints for session-start operations don't actually use the database - they just call MemoryManager functions."
    },
    {
      "subject": "user-prompt-submit hook uses daemon HTTP API for semantic search of episodic and thinking memories",
      "keywords": ["user-prompt-submit", "hook", "semantic search", "daemon-client", "http", "episodic", "thinking"],
      "applies_to": "file:src/hooks/user-prompt-submit.ts",
      "content": "## Implementation\n\nThe user-prompt-submit hook performs semantic search via daemon HTTP API:\n\n1. Receives user prompt input\n2. Loads configuration (episodicEnabled, thinkingEnabled, similarity thresholds, token limits)\n3. Calls daemon HTTP endpoints:\n   - `POST /api/search/episodic` - if episodicEnabled\n   - `POST /api/search/thinking` - if thinkingEnabled\n4. Combines results from both memory types\n5. Outputs formatted memories to stdout\n\n## HTTP Requests\n\nEach search request includes:\n- `query`: The user's prompt\n- `limit`: Max number of results\n- `minSimilarity`: Threshold (0.0-1.0)\n- `maxTokens`: Token budget\n\n## Configuration\n\nSeparate configuration for each memory type:\n- `episodicMaxTokens` (default: 1000)\n- `episodicMinSimilarity` (default: 0.8)\n- `thinkingMaxTokens` (default: 1000)\n- `thinkingMinSimilarity` (default: 0.8)"
    },
    {
      "subject": "daemon-client.ts provides HTTP client for hooks to communicate with daemon",
      "keywords": ["daemon-client", "http-client", "fetch", "json", "error-handling", "retry"],
      "applies_to": "file:src/utils/daemon-client.ts",
      "content": "## Purpose\n\nThe DaemonClient is a wrapper around HTTP fetch that simplifies communication between hooks and the daemon. Hooks use this client instead of directly accessing the database.\n\n## Key Methods\n\n- `searchEpisodic(query, options)` - Search episodic memories\n- `searchThinking(query, options)` - Search thinking memories\n- `listRecentMemories(limit)` - Get recent memories\n\n## Error Handling\n\nThe client handles:\n- Network errors (daemon not running)\n- HTTP error responses\n- JSON parsing errors\n- Timeout handling\n\n## Configuration\n\nDaemon URL comes from:\n1. `DAEMON_URL` environment variable\n2. Default: `http://localhost:9090` (or configurable port)"
    },
    {
      "subject": "HTTP server implementation in daemon exposes search and memory endpoints",
      "keywords": ["http-server", "daemon", "api-design", "express", "routing", "port-management"],
      "applies_to": "file:src/mcp-server/http-server.ts",
      "content": "## Server Details\n\nThe HTTP server runs in the daemon process and exposes REST API endpoints:\n\n### Endpoints\n\n- `POST /api/search/episodic` - Search episodic memories\n- `POST /api/search/thinking` - Search thinking memories  \n- `GET /api/memories/recent?limit=5` - Get recent memories\n- `GET /health` - Health check\n\n### Request Format\n\nSearch endpoints accept JSON:\n```json\n{\n  \"query\": \"user prompt\",\n  \"limit\": 10,\n  \"minSimilarity\": 0.8,\n  \"maxTokens\": 1000\n}\n```\n\n### Response Format\n\nReturns array of memories with score, id, subject, content:\n```json\n{\n  \"memories\": [\n    {\n      \"id\": \"uuid\",\n      \"subject\": \"...\",\n      \"content\": \"...\",\n      \"score\": 0.85,\n      \"appliesTo\": \"global\"\n    }\n  ]\n}\n```\n\n### Port Configuration\n\nPort is configurable via environment variable, defaults to 9090."
    }
  ]
}
```
