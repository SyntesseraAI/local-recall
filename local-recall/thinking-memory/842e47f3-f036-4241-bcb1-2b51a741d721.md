---
id: 842e47f3-f036-4241-bcb1-2b51a741d721
subject: >-
  This gives me a good picture of the issue. Now let me provide a comprehensive
  answer about what...
applies_to: global
occurred_at: '2025-12-03T09:47:49.869Z'
content_hash: b8cff1e4ea6ef72d
---
## Thought

This gives me a good picture of the issue. Now let me provide a comprehensive answer about what "Invalid argument" means for the mutex exception in the context of sqlite-vec.

## Output

Based on my research, here's a deep analysis of the "mutex lock failed: Invalid argument" error:

## Root Cause

The error `libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument` occurs when `pthread_mutex_lock()` returns `EINVAL`. This happens when:

**A thread attempts to lock a mutex that has already been destroyed.**

Specifically in the context of sqlite-vec:

1. **sqlite-vec uses internal C++ mutexes** for thread safety
2. **During Node.js process exit**, the C++ destructors run and destroy these mutexes
3. **If any code tries to access sqlite-vec after destruction** (even cleanup code), the mutex is already deallocated
4. `pthread_mutex_lock()` returns `EINVAL` because the mutex structure is invalid/corrupted

## Why It Happens With sqlite-vec

The sqlite-vec extension keeps internal state with mutexes. The destruction order during process exit is:

```
1. Node.js starts shutdown
2. Native addon destructors run
3. sqlite-vec internal mutexes get destroyed
4. Some deferred/pending callback tries to access sqlite-vec
5. EINVAL â†’ crash
```

## Your Codebase Already Has Mitigations

Looking at `src/core/vector-store.ts:6-9` and `src/utils/database.ts`:

```typescript
// IMPORTANT: Database connections are ephemeral - opened for each operation and
// closed immediately after. This prevents "mutex lock failed: Invalid argument"
// errors that occur when sqlite-vec's internal mutexes are accessed after being
// destroyed during process exit.
```

You've implemented:
1. **Ephemeral connections** - open/close for each operation
2. **File-based locking** - prevents concurrent sqlite-vec loading
3. **Retry logic** - handles transient lock errors

## Likely Remaining Cause

The error is still occurring, which suggests:

1. **Concurrent hook execution** - Two hooks running simultaneously, both trying to load sqlite-vec
2. **Race condition in lock acquisition** - The file-based lock in `database.ts:53-103` may have a race window
3. **sqlite-vec loaded by MCP daemon + hook simultaneously** - Even with ephemeral connections, if two processes load the extension at the exact same time, the native code may conflict

## Solutions

1. **Use a more robust locking mechanism** (e.g., `proper-lockfile` npm package instead of manual O_EXCL)
2. **Serialize all database access** through a single process (MCP daemon only)
3. **Disable hooks that access the database** when the MCP daemon is running

Sources:
- [Apache Arrow Issue #15189 - mutex lock failed on macOS](https://github.com/apache/arrow/issues/15189)
- [Stack Overflow - What does mutex lock fail with invalid argument mean?](https://stackoverflow.com/questions/30090108/what-does-mutex-lock-fail-with-invalid-argument-mean)
- [isolated-vm Issue #4 - Mutex lock failed](https://github.com/laverdet/isolated-vm/issues/4)
