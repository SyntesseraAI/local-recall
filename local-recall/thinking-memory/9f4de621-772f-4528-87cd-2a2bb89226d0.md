---
id: 9f4de621-772f-4528-87cd-2a2bb89226d0
subject: >-
  As I suspected - `maxMemories` is only used in tests, not in actual code. So
  it's a configuration...
applies_to: global
occurred_at: '2025-11-29T22:55:53.490Z'
content_hash: 164b9b1a42e0a7d0
---
## Thought

As I suspected - `maxMemories` is only used in tests, not in actual code. So it's a configuration option that exists but isn't enforced anywhere. The memories don't get compacted.

Let me summarize for the user.

## Output

**No, memories are not compacted.** Here's what exists vs. what doesn't:

### What exists (deduplication only)

The `MemoryManager` has basic **duplicate prevention** at creation time (`src/core/memory.ts:52-67`):

```typescript
async findDuplicate(occurredAt: string, contentHash: string): Promise<Memory | null>
```

- Before creating a memory, it checks if one with the same `occurred_at` timestamp AND `content_hash` already exists
- If found, it returns the existing memory instead of creating a duplicate
- This is **idempotent creation**, not compaction

### What doesn't exist

- **No memory merging** - similar memories are never consolidated
- **No summarization** - old memories aren't condensed
- **No pruning** - old/unused memories aren't automatically deleted
- **No limit enforcement** - the `maxMemories: 1000` config option is defined but **never actually enforced** in the code (only referenced in tests)

### Current behavior

Memories accumulate indefinitely. The only constraints are:
1. Duplicate prevention via `occurred_at` + `content_hash` matching
2. Manual deletion via the MCP `memory_delete` tool

This could be a good feature to add - compaction strategies like:
- Merging memories with similar subjects/keywords
- Summarizing older memories
- Enforcing the `maxMemories` limit with LRU eviction
- Time-based pruning
