---
id: 391f892a-330e-450d-953e-46dc1beb874d
subject: >-
  Now I understand the architecture better. The system is using cross-process
  file locking...
applies_to: global
occurred_at: '2025-12-03T10:32:33.972Z'
content_hash: 0d954950b320c49b
---
## Thought

Now I understand the architecture better. The system is using cross-process file locking (`withDbMutex`) to prevent concurrent sqlite-vec access. However, the mutex error is still happening.

The problem is likely that the "mutex lock failed: Invalid argument" error is NOT about SQLite's database lock - it's about sqlite-vec's INTERNAL pthread mutex. This happens when:

1. The sqlite-vec extension is loaded, which creates internal pthread mutexes
2. When the process exits, these mutexes are destroyed
3. If any code tries to access these mutexes AFTER they've been destroyed (during process cleanup), you get "mutex lock failed: Invalid argument"

This is a well-known issue with native modules that use pthread mutexes. The file-based locking doesn't help because:
1. The error occurs during process SHUTDOWN, not during operation
2. It's about accessing destroyed resources, not concurrent access

Looking at the vector stores, I see they:
1. Open ephemeral connections 
2. Close them after each operation
3. Use `withDbMutex` for locking

But here's the issue - the error is happening in the UserPromptSubmit hook (a child process). The problem may be:

1. **Process exit race condition**: When the hook process exits, node.js's garbage collector may be cleaning up sqlite-vec's internal resources while other code is still trying to use them
2. **sqlite-vec state corruption**: Loading sqlite-vec, even when protected by file lock, creates process-local state that can get corrupted on exit

The original architecture with the HTTP daemon was designed to avoid this problem entirely - the hooks would NOT load sqlite-vec at all, they would just make HTTP calls to the daemon which owns the sqlite-vec extension.

Looking at git status:
- `D src/mcp-server/http-server.ts` - deleted
- `D src/utils/daemon-client.ts` - deleted

These were the components that made the HTTP daemon architecture work. Without them, hooks directly load sqlite-vec and encounter the mutex errors.
 
I see three potential approaches to resolve the mutex synchronization challenges. Restoring the HTTP daemon would isolate sqlite-vec operations in a dedicated process. Alternatively, implementing precise exit handling could prevent resource destruction conflicts. A third option involves spawning dedicated subprocesses for vector database interactions, which would create clean process boundaries.

The core issue seems to stem from complex threading interactions during process lifecycle management. Careful synchronization and resource cleanup will be critical to preventing these mutex-related failures.

The sqlite-vec extension appears particularly sensitive to multi-process loading scenarios, especially when different processes attempt concurrent access to shared library state and database resources. This suggests a need for more robust inter-process coordination mechanisms.

The recommended architectural approach involves centralizing sqlite-vec library loading within a single daemon process, with other processes communicating through HTTP interfaces. This design prevents mutex initialization conflicts and ensures safer, more controlled database interactions.

Current implementation lacks proper daemon availability checks before attempting direct SearchEngine instantiation. The code should implement a fallback strategy: first verifying daemon health, then either fetching results via HTTP or gracefully switching to a read-only mode that avoids potential library initialization conflicts.

The core challenge stems from sqlite-vec's internal pthread mutex management, which remains problematic even with file-based locking mechanisms. Simply toggling the readonly flag doesn't prevent these low-level synchronization issues across multiple processes.

## Output

Now I understand the issue. The file-based locking (`withDbMutex`) is serializing database access across processes, but **the mutex error is coming from sqlite-vec's internal pthread mutexes, not SQLite's database locks**.

The problem is:

1. **sqlite-vec uses internal C++ mutexes** for its vector operations
2. When the hook process loads sqlite-vec, it creates process-local mutex state
3. These internal mutexes can fail with "Invalid argument" when:
   - The process is exiting and cleanup happens in wrong order
   - Multiple processes have loaded the same shared library
   - Memory corruption occurs during concurrent native operations

The file lock prevents concurrent *database* access, but doesn't prevent issues with sqlite-vec's internal state.

**The original design (per CLAUDE.md) was correct** - hooks should communicate with the daemon via HTTP, not load sqlite-vec directly. The deleted files were:
- `src/utils/daemon-client.ts` - HTTP client for hooks
- `src/mcp-server/http-server.ts` - HTTP API on the daemon

**Current broken flow:**
```
Hook Process → loads sqlite-vec → mutex error
```

**Intended safe flow (per docs):**
```
Hook Process → HTTP request → Daemon (owns sqlite-vec) → response
```

You have two options:

1. **Restore the HTTP daemon architecture** - re-add the daemon-client and http-server components
2. **Disable the hook's vector search** and rely only on the MCP tools (which run in the daemon)

Would you like me to:
- Look at what the deleted daemon-client.ts and http-server.ts contained (via git)?
- Implement a simpler workaround that disables vector search in hooks entirely?
