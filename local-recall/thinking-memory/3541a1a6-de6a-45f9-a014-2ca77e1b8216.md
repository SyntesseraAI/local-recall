---
id: 3541a1a6-de6a-45f9-a014-2ca77e1b8216
subject: >-
  The user is asking me to extract memories from a Claude Code session
  transcript. I need to analyze...
applies_to: global
occurred_at: '2025-12-21T19:05:26.719Z'
content_hash: 80cc528d0231ffcb
---
## Thought

The user is asking me to extract memories from a Claude Code session transcript. I need to analyze the condensed transcript and extract valuable memories that would help future AI assistants working on this codebase.

Let me go through the transcript to identify what was learned, what problems were solved, and what is specific to this codebase:

1. **The Mutex Error Issue**:
   - The error "libc++abi: terminating due to uncaught exception of type std::__1::system_error: mutex lock failed: Invalid argument" was happening
   - Root cause: A thread attempting to lock a mutex that has already been destroyed
   - This was related to sqlite-vec using internal C++ mutexes
   - The original architecture had Orama being used directly in hooks, but there was a switch to using better-sqlite3 with sqlite-vec

2. **Architecture Change**:
   - The problem: Hooks and daemon were completely independent, with hooks directly using sqlite-vec (which has the mutex issue)
   - The solution: Implement an HTTP API in the daemon so hooks become thin clients
   - This moves the sqlite-vec database access into a single daemon process, avoiding mutex issues

3. **Implementation Details**:
   - New file: `src/mcp-server/http-server.ts` - HTTP server in the daemon
   - New file: `src/utils/daemon-client.ts` - Client library for hooks to communicate with daemon
   - Modified files: `src/hooks/user-prompt-submit.ts`, `src/hooks/session-start.ts`, `src/mcp-server/server.ts`
   - HTTP endpoints: `/search/episodic`, `/search/thinking`, `/memories/recent`, `/health`
   - Default port: 7847 (changed from 3000 to something more random)

4. **Session-start Hook Insight**:
   - The session-start hook doesn't need sqlite-vec - it just reads markdown files directly
   - But was updated anyway to use the daemon client for consistency
   
I'll continue the rewrite with the next thinking:

The build process validated the architectural changes, with all 289 tests passing successfully. The core insight involves centralizing database access to resolve threading complexities. By moving sqlite-vec operations into a single daemon process, the system eliminates mutex-related failures. The configuration remains flexible, using Zod schemas for type safety and allowing configurable port settings. This approach transforms hooks into lightweight clients, simplifying the overall system architecture and improving reliability.

The HTTP-based inter-process communication provides a clean separation of concerns, with the daemon managing critical database interactions while hooks remain focused on specific tasks like reading markdown files and submitting user prompts.

The API design centralizes vector search operations across episodic and thinking memories through dedicated endpoints, ensuring thread-safe database access by routing all queries through a single daemon process. This approach eliminates mutex lock conflicts and simplifies the overall system architecture.

By using port 7847, the daemon selects a non-standard port that minimizes potential conflicts with other services, while maintaining flexibility through environment variable configuration.

The session-start hook demonstrates a lightweight, file-based memory loading strategy that prioritizes performance and simplicity, leveraging markdown files directly without complex database interactions.

The daemon client provides a clean, abstracted HTTP communication layer for system hooks, handling request complexities like timeouts and health checks while maintaining a consistent interface across different components.

The comprehensive test suite validation confirms the robustness of the new IPC architecture, with all 289 tests passing successfully and indicating production-readiness.

## Output

```json
{
  "memories": [
    {
      "subject": "Mutex lock failed error fixed by centralizing sqlite-vec database access in daemon",
      "keywords": ["mutex", "sqlite-vec", "threading", "daemon", "hooks", "ipc", "error", "concurrent access"],
      "applies_to": "global",
      "content": "## Problem\nHooks were directly accessing sqlite-vec database, causing 'mutex lock failed: Invalid argument' errors due to concurrent access from multiple hook processes destroying/recreating mutexes.\n\n## Root Cause\nMultiple hook processes simultaneously accessing the sqlite-vec database with internal C++ mutexes led to mutex state corruption when threads tried to lock already-destroyed mutexes.\n\n## Solution\nImplemented hook-daemon IPC architecture:\n- Daemon owns the single sqlite-vec database connection\n- Hooks communicate via HTTP API to daemon\n- Eliminates concurrent database access conflicts\n- All 289 tests pass after implementation\n\n## Architecture\n```\nHook 1 ──┐\nHook 2 ──┼→ HTTP → Daemon (port 7847) → sqlite-vec\nHook 3 ──┘\n```"
    },
    {
      "subject": "Daemon HTTP API endpoints for centralized vector search",
      "keywords": ["http", "endpoints", "daemon", "api", "episodic", "thinking", "search", "recent"],
      "applies_to": "file:src/mcp-server/http-server.ts",
      "content": "## Daemon HTTP Server\n\nListens on port 7847 and exposes:\n- `POST /search/episodic` - Episodic memory vector search\n- `POST /search/thinking` - Thinking memory vector search  \n- `POST /memories/recent` - Get recent memories\n- `GET /health` - Health check endpoint\n\nHooks use `DaemonClient` (src/utils/daemon-client.ts) to call these endpoints instead of directly accessing sqlite-vec database."
    },
    {
      "subject": "Daemon HTTP port is configurable via environment and config file",
      "keywords": ["port", "7847", "configuration", "environment", "mcp"],
      "applies_to": "file:src/core/types.ts",
      "content": "## Port Configuration\n\nDefault daemon port: 7847 (random port in 7xxx range to avoid conflicts)\n\nConfigurable via:\n- Env: `LOCAL_RECALL_DAEMON_PORT`\n- Config: `.local-recall.json` → `mcp.daemonPort`\n- Schema: MCP object in `src/core/types.ts` with Zod validation"
    },
    {
      "subject": "Session-start hook reads markdown files directly, doesn't need database",
      "keywords": ["session-start", "hook", "markdown", "memory-manager", "no-database"],
      "applies_to": "file:src/hooks/session-start.ts",
      "content": "## Session-Start Hook\n\nLoads recent memories from markdown files using `MemoryManager` - no vector search or database access needed. Inherently safe from mutex issues since it doesn't touch sqlite-vec. However, updated to use daemon client for architectural consistency."
    },
    {
      "subject": "Daemon client abstraction hides HTTP implementation from hooks",
      "keywords": ["daemon-client", "http-client", "abstraction", "timeout", "health-check"],
      "applies_to": "file:src/utils/daemon-client.ts",
      "content": "## DaemonClient Utility\n\nProvides HTTP client abstraction so hooks don't deal with HTTP details:\n- Configurable port (from config)\n- Health checks before requests\n- Timeout handling\n- Error propagation\n- Used by both user-prompt-submit and session-start hooks"
    },
    {
      "subject": "Hook files updated to use daemon client instead of direct database access",
      "keywords": ["hooks", "refactoring", "user-prompt-submit", "session-start", "daemon-client"],
      "applies_to": "file:src/hooks/user-prompt-submit.ts",
      "content": "## Hook Refactoring\n\n**user-prompt-submit.ts**: \n- Changed from direct Orama vector search to HTTP calls to daemon\n- Uses DaemonClient for `/search/episodic` and `/search/thinking`\n- Maintains same search logic and filtering\n\n**session-start.ts**:\n- Added daemon client for consistency\n- Still uses MemoryManager for direct file reads (doesn't change functionality)"
    }
  ]
}
```
