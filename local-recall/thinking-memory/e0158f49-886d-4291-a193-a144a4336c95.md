---
id: e0158f49-886d-4291-a193-a144a4336c95
subject: >-
  Now I understand the full picture. The current implementation: 1. Uses a
  single JSON file with a...
applies_to: global
occurred_at: '2025-11-30T21:22:53.235Z'
content_hash: 54e47f88e21fd30f
---
Now I understand the full picture. The current implementation:
1. Uses a single JSON file with a `transcripts` record
2. Has a cache in memory
3. Supports operations like add, remove, check, and list

For JSONL format:
- Each line will be a JSON object representing an operation
- We can use an "action" field to differentiate between "add" and "remove"
- On load, we process all lines to build the current state
- For appending, we just add new lines
- For removes, we append a "remove" line

The file will be `processed-log.jsonl` instead of `processed-log.json`.

Let me design the new schema:

```jsonl
{"action":"add","filename":"test.jsonl","sourcePath":"/source/test.jsonl","contentHash":"abc123","lastModified":"2024-01-01T00:00:00.000Z","processedAt":"2024-01-01T00:00:00.000Z","memoriesCreated":["id1","id2"]}
{"action":"remove","filename":"test.jsonl","removedAt":"2024-01-01T00:00:00.000Z"}
```

Actually, looking more carefully at the usage pattern:
- `recordProcessed` is called when a transcript is processed successfully
- `removeEntry` is called when a transcript has changed and needs re-processing (to clean up old memories)

Since removes are followed by adds (for re-processing), we could simplify:
- Just append entries with the latest state
- When loading, the last entry for each filename wins
- This makes "remove" implicit - if we want to remove, we just don't add a new entry

But we need explicit removes for the case where a transcript is deleted and shouldn't be processed again. Let me check how removeEntry is used...

Looking at the code, `removeEntry` returns memory IDs so they can be deleted. Then presumably the transcript will be re-processed and a new entry added.


I'll implement a straightforward JSONL tracking system. The approach involves creating a log file where each line represents a distinct action. We'll track file processing with explicit add and remove operations, ensuring a clear audit trail of transcript handling. The implementation will support appending new entries and maintaining the most recent state for each unique filename.
