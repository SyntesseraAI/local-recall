---
id: d4cf4edb-3e34-487d-9c75-a6fd97189585
subject: >-
  Now I see the issue more clearly. The problem is the singleton pattern
  combined with how the...
applies_to: global
occurred_at: '2025-12-03T09:29:53.371Z'
content_hash: f83fa461eb413c6c
---
## Thought

Now I see the issue more clearly. The problem is the singleton pattern combined with how the database connections are being used. Let me look at the search.ts file and user-prompt-submit-thinking.ts to see how these are being used.

The research shows that the "mutex lock failed: Invalid argument" error happens when:
1. A mutex is accessed after it has been destroyed
2. The database connection object gets garbage collected or destroyed while still in use

The issue is likely that:
1. The singleton instances (`vectorStoreInstance`, `thinkingVectorStoreInstance`) are being held globally
2. When the hook process exits, Node.js may garbage collect these objects in an unpredictable order
3. The sqlite-vec native extension has internal mutexes that get destroyed, but some cleanup code tries to use them

The solution is exactly what the user suggested: **connections should only exist for atomic operations**. Instead of using singletons that persist for the lifetime of the process, we should:
1. Open a fresh database connection for each operation
2. Close it immediately after the operation completes
3. Never store connections in global/module-level variables

Let me check the search.ts to understand the full flow.

## Output

Let me also check the search engine and the thinking hook:
