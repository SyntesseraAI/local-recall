---
id: 321de093-dd4f-47e2-9b1a-fe7cfa397219
subject: >-
  Interesting! The SQLite is compiled with `THREADSAFE=2` which is
  **multi-thread mode**, NOT...
applies_to: global
occurred_at: '2025-12-03T10:33:49.616Z'
content_hash: 1ccdd27e4f79130d
---
## Thought

Interesting! The SQLite is compiled with `THREADSAFE=2` which is **multi-thread mode**, NOT serialized mode.

SQLite threading modes:
- `THREADSAFE=0` - Single-thread mode (no mutexes)
- `THREADSAFE=1` - Serialized mode (fully thread-safe, all access serialized)
- `THREADSAFE=2` - Multi-thread mode (safe if different threads use different connections, but NOT safe if same connection used by multiple threads)

And I also see `MUTEX_PTHREADS` which means SQLite is using pthread mutexes.

The problem is:
1. **THREADSAFE=2 (multi-thread)** means SQLite assumes each connection is used by only one thread at a time
2. The sqlite-vec extension likely has its own internal mutexes that may have similar assumptions
3. When multiple processes load the same sqlite-vec shared library and access the same database file, even with file locking, the internal mutex state in sqlite-vec may get corrupted

The fact that this is multi-thread mode (2) rather than serialized mode (1) could be contributing to the issue. In multi-thread mode, SQLite doesn't serialize all operations internally - it relies on the caller to ensure thread safety for each connection.

However, the bigger issue is probably still sqlite-vec's internal C++ mutexes, not SQLite's threading mode. The error message "mutex lock failed: Invalid argument" with `libc++abi` suggests it's a C++ std::mutex issue, not a pthread_mutex issue from SQLite.

Let me explain this to the user.

## Output

This confirms the issue. SQLite is running in **multi-thread mode** (`THREADSAFE=2`), **not serialized mode** (`THREADSAFE=1`).

**Threading modes:**
| Mode | Value | Behavior |
|------|-------|----------|
| Single-thread | 0 | No mutexes, not thread-safe |
| **Serialized** | 1 | Fully thread-safe, all operations serialized internally |
| **Multi-thread** | 2 | Safe only if each connection used by one thread at a time |

With `THREADSAFE=2`:
- SQLite assumes each database connection is accessed by **only one thread at a time**
- It does NOT serialize all operations internally
- The caller must ensure thread/process safety

This is problematic because:
1. better-sqlite3 ships with SQLite compiled in multi-thread mode
2. sqlite-vec has its own internal C++ `std::mutex` structures
3. Multiple processes loading sqlite-vec can corrupt these internal mutex states

The `MUTEX_PTHREADS` compile option shows SQLite uses pthread mutexes, but the error you're seeing (`libc++abi: ... std::__1::system_error: mutex lock failed`) is from **sqlite-vec's C++ code**, not SQLite itself.

**Options to investigate:**

1. **Check if better-sqlite3 can be rebuilt with THREADSAFE=1** (requires native compilation)
2. **Revert to HTTP daemon architecture** - only one process loads sqlite-vec
3. **Use a separate subprocess** for sqlite-vec operations

Would you like me to check if there's a way to configure better-sqlite3's threading mode at runtime, or explore restoring the daemon architecture?
