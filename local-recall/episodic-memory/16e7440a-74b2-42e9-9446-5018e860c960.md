---
id: 16e7440a-74b2-42e9-9446-5018e860c960
subject: onnxruntime-node mutex errors after Orama migration - file lock solution
keywords:
  - mutex
  - fastembed
  - onnxruntime-node
  - native bindings
  - concurrent processes
  - proper-lockfile
  - embedding lock
applies_to: global
occurred_at: '2025-12-21T19:21:53.918Z'
content_hash: 2b64f402d062839c
---
## Problem

After migrating from sqlite-vec to Orama, mutex errors persisted because the hooks were still loading `fastembed` directly. While Orama is pure JavaScript, `fastembed` depends on `onnxruntime-node` which has native bindings that cause mutex lock contention when multiple hook processes load it concurrently.

## Root Cause Analysis

- `onnxruntime-node` (used by fastembed) has the same native mutex issue as sqlite-vec
- When multiple Claude Code hook processes run in parallel, they all try to load the native module
- This causes mutex lock contention and crashes

## Solution Implemented

Used `proper-lockfile` package to serialize access to fastembed/onnxruntime-node:

- Added file-based lock at `/tmp/local-recall-embedding.lock`
- Lock wraps both initialization and embedding operations
- Retries up to 10 times with exponential backoff (100ms - 2s)
- Stale lock timeout: 30 seconds
- Prevents concurrent native module loading

## Implementation Details

File: `src/core/embedding.ts`
- Import: `import lockfile from 'proper-lockfile'`
- Private method `withEmbeddingLock()` wraps async operations
- All native module access goes through the lock
- Logs "Acquired embedding lock" and "Released embedding lock" messages

## Why This Works

File locks are OS-level primitives that work across process boundaries - perfect for preventing concurrent access to native modules when hooks run in parallel.
